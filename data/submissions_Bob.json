{
  "submissions_dump": [
    {
      "id": 230300055,
      "lang": "java",
      "time": "1\u00a0week, 1\u00a0day",
      "timestamp": 1558407935,
      "status_display": "Accepted",
      "runtime": "3 ms",
      "url": "/submissions/detail/230300055/",
      "is_pending": "Not Pending",
      "title": "Roman to Integer",
      "memory": "35.6 MB",
      "code": "class Solution {\n    public int romanToInt(String s) {\n        \n        int total = 0;\n        for(int i=0;i<s.length()-1;i++){\n            \n            int curr = getVal(s.charAt(i));\n            int next = getVal(s.charAt(i+1));\n            if(curr < next){\n                total -= curr;\n            } else{\n                total += curr;\n            }\n        }\n        total+= getVal(s.charAt(s.length()-1));\n        return total;\n        \n    }\n    \n    public int getVal(char c){\n        switch(c){\n            case 'M': return 1000;\n            case 'D': return 500;\n            case 'C': return 100;\n            case 'L': return 50;\n            case 'X': return 10;\n            case 'V': return 5;\n            case 'I': return 1;\n        }\n        throw new IllegalArgumentException(\"Not valid charcter\");\n    }\n}",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 230297765,
      "lang": "java",
      "time": "1\u00a0week, 1\u00a0day",
      "timestamp": 1558407341,
      "status_display": "Accepted",
      "runtime": "3 ms",
      "url": "/submissions/detail/230297765/",
      "is_pending": "Not Pending",
      "title": "Integer to Roman",
      "memory": "35.1 MB",
      "code": "class Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb = new StringBuilder();\n        String[] roman = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        int i = 0;\n        while(num>0){\n            while(num>=val[i]){\n                sb.append(roman[i]);\n                num-=val[i];\n            }\n            i++;\n        }\n        return sb.toString();\n    }\n}",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 230296359,
      "lang": "java",
      "time": "1\u00a0week, 1\u00a0day",
      "timestamp": 1558406984,
      "status_display": "Accepted",
      "runtime": "1 ms",
      "url": "/submissions/detail/230296359/",
      "is_pending": "Not Pending",
      "title": "Squares of a Sorted Array",
      "memory": "39.9 MB",
      "code": "// What could efficient solution be?\n//  Look at break-point -ve and +ve numbers.\n\n// Take absolute of negative numnbers and place them accordingly.\n// Make sure you get a squared array in ascending order....\n\n// Efficient Solution: USing Two-pointer approach\n// Do comparison between first and last element in array.\n// The way I'm doing is square and add number to arrayList. Sort the array list and return the reuslt as int array\n\nclass Solution {\n    public int[] sortedSquares(int[] A) {\n        int n = A.length; //Length of the array\n        int[] temp = new int[n];\n        \n        int i=0, j = n-1;\n        for(int k=n-1;k>=0;k--)\n        {\n            if(Math.abs(A[i]) > (Math.abs(A[j])))\n            {\n                temp[k] = A[i] * A[i];\n                i++;\n                \n            }\n            else\n            {\n                temp[k] = A[j] * A[j];\n                j--;\n            }\n        }\n        \n        //return the temp resulting array\n        return temp;\n    }\n}",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 230294615,
      "lang": "java",
      "time": "1\u00a0week, 1\u00a0day",
      "timestamp": 1558406556,
      "status_display": "Accepted",
      "runtime": "12 ms",
      "url": "/submissions/detail/230294615/",
      "is_pending": "Not Pending",
      "title": "Squares of a Sorted Array",
      "memory": "40 MB",
      "code": "// What could efficient solution be?\n//  Look at break-point -ve and +ve numbers.\n\n// Take absolute of negative numnbers and place them accordingly.\n// Make sure you get a squared array in ascending order....\n\n// The way I'm doing is square and add number to arrayList. Sort the array list and return the reuslt as int array\n\nclass Solution {\n    public int[] sortedSquares(int[] A) {\n        if(A.length == 0)\n            return null;\n        \n        List<Integer> list = new ArrayList<>();\n        for(int x: A)\n        {\n            list.add(x*x);\n        }\n        \n        Collections.sort(list);\n        int[] temp = new int[list.size()];\n        \n        for(int i=0;i<list.size();i++)\n            temp[i] = list.get(i);\n        \n        return temp;\n    }\n}",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 230294456,
      "lang": "java",
      "time": "1\u00a0week, 1\u00a0day",
      "timestamp": 1558406515,
      "status_display": "Accepted",
      "runtime": "2 ms",
      "url": "/submissions/detail/230294456/",
      "is_pending": "Not Pending",
      "title": "Container With Most Water",
      "memory": "39.5 MB",
      "code": "class Solution {\n    public int maxArea(int[] height) {\n        int i = 0;\n        int j = height.length - 1;\n        int maxArea = 0;\n        while(i < j){\n            maxArea = Math.max(maxArea, (Math.min(height[i], height[j])*(j-i)));\n            if(height[i] > height[j]){\n                j--;\n            } else{\n                i++;\n            }\n        }\n        return maxArea;\n    }\n}",
      "compare_result": "11111111111111111111111111111111111111111111111111"
    },
    {
      "id": 230293907,
      "lang": "java",
      "time": "1\u00a0week, 1\u00a0day",
      "timestamp": 1558406378,
      "status_display": "Accepted",
      "runtime": "12 ms",
      "url": "/submissions/detail/230293907/",
      "is_pending": "Not Pending",
      "title": "Squares of a Sorted Array",
      "memory": "39.7 MB",
      "code": "// The way I'm doing is square and add number to arrayList. Sort the array list and return the reuslt as int array\n\nclass Solution {\n    public int[] sortedSquares(int[] A) {\n        if(A.length == 0)\n            return null;\n        \n        List<Integer> list = new ArrayList<>();\n        for(int x: A)\n        {\n            list.add(x*x);\n        }\n        \n        Collections.sort(list);\n        int[] temp = new int[list.size()];\n        \n        for(int i=0;i<list.size();i++)\n            temp[i] = list.get(i);\n        \n        return temp;\n    }\n}",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 213130860,
      "lang": "cpp",
      "time": "2\u00a0months, 3\u00a0weeks",
      "timestamp": 1551998499,
      "status_display": "Accepted",
      "runtime": "8 ms",
      "url": "/submissions/detail/213130860/",
      "is_pending": "Not Pending",
      "title": "Min Cost Climbing Stairs",
      "memory": "10.5 MB",
      "code": "class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        if(!n)\n            return 0;\n        vector<int> dp(n+1,0);\n        //dp[0] = cost[0];\n        //dp[1] = min(cost[0],cost[1]);\n        for(int i=2; i<=n; i++) {\n            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);\n        }\n        return dp[n];\n    }\n};",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 213130590,
      "lang": "cpp",
      "time": "2\u00a0months, 3\u00a0weeks",
      "timestamp": 1551998395,
      "status_display": "Accepted",
      "runtime": "16 ms",
      "url": "/submissions/detail/213130590/",
      "is_pending": "Not Pending",
      "title": "Min Cost Climbing Stairs",
      "memory": "10.3 MB",
      "code": "class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        if(!n)\n            return 0;\n        vector<int> dp(n+1,0);\n        //dp[0] = cost[0];\n        //dp[1] = min(cost[0],cost[1]);\n        for(int i=2; i<=n; i++) {\n            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);\n        }\n        return dp.back();\n    }\n};",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 212055064,
      "lang": "cpp",
      "time": "2\u00a0months, 3\u00a0weeks",
      "timestamp": 1551641137,
      "status_display": "Accepted",
      "runtime": "348 ms",
      "url": "/submissions/detail/212055064/",
      "is_pending": "Not Pending",
      "title": "Design Search Autocomplete System",
      "memory": "114.7 MB",
      "code": "struct TrieNode {\n    unordered_map<char, TrieNode*> child;\n    string str;\n    int count;\n};\n\nclass AutocompleteSystem {\nprivate: \n    void insert(string s, TrieNode* root, int times){\n        TrieNode* curr = root;\n        for (int i=0;i<s.size();i++){\n            if (!curr->child.count(s[i]))\n                curr->child[s[i]] = new TrieNode();\n            curr = curr->child[s[i]];\n        }\n        curr->count += times;\n        curr->str = s;\n    }\n    \npublic:\n    void dfs(TrieNode* temp){\n        if (temp->str != \"\") q.push({temp->str, temp->count});\n        \n        for (auto& ele: temp->child){\n            dfs(ele.second);\n        }\n    }\n    \n    struct comp{\n        bool operator() (pair<string, int>& a, pair<string, int>& b){\n            return a.second<b.second || a.second==b.second && a.first>b.first;\n        }\n    };\n    \n    priority_queue<pair<string, int>, vector<pair<string, int> >, comp> q;\n        \n    TrieNode* root = new TrieNode();\n    TrieNode *curr;\n    AutocompleteSystem(vector<string> sentences, vector<int> times) {\n        //root = new TrieNode();\n        for (int i=0;i<sentences.size();i++){\n            insert(sentences[i], root, times[i]);\n        }\n        curr = root;\n    }\n    \n    \n    string s=\"\";\n    vector<string> input(char c) {\n        q = priority_queue<pair<string, int>, vector<pair<string, int> >, comp>();\n        if (c=='#'){\n            insert(s, root, 1);\n            s=\"\";\n            curr = root; //start searching from the beginning node for the next sentence\n            return {};\n        }\n        s += c;\n        if (curr && curr->child.count(c)){\n            curr = curr->child[c];\n        }else{\n            curr = NULL; //curr node is null so empty result for any further characters in current input \n            return {};\n        }\n        \n        if (curr->str != \"\") q.push({curr->str, curr->count});\n        for (auto& ele: curr->child){\n            dfs(ele.second);\n        }\n        \n        vector<string> res;\n        while (!q.empty() && res.size()<3){\n            res.push_back(q.top().first);\n            q.pop();\n        }\n        \n        return res;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111111111111"
    },
    {
      "id": 212055033,
      "lang": "cpp",
      "time": "2\u00a0months, 3\u00a0weeks",
      "timestamp": 1551641128,
      "status_display": "Accepted",
      "runtime": "352 ms",
      "url": "/submissions/detail/212055033/",
      "is_pending": "Not Pending",
      "title": "Design Search Autocomplete System",
      "memory": "114.8 MB",
      "code": "struct TrieNode {\n    unordered_map<char, TrieNode*> child;\n    string str;\n    int count;\n};\n\nclass AutocompleteSystem {\nprivate: \n    void insert(string s, TrieNode* root, int times){\n        TrieNode* curr = root;\n        for (int i=0;i<s.size();i++){\n            if (!curr->child.count(s[i]))\n                curr->child[s[i]] = new TrieNode();\n            curr = curr->child[s[i]];\n        }\n        curr->count += times;\n        curr->str = s;\n    }\n    \npublic:\n    void dfs(TrieNode* temp){\n        if (temp->str != \"\") q.push({temp->str, temp->count});\n        \n        for (auto& ele: temp->child){\n            dfs(ele.second);\n        }\n    }\n    \n    struct comp{\n        bool operator() (pair<string, int>& a, pair<string, int>& b){\n            return a.second<b.second || a.second==b.second && a.first>b.first;\n        }\n    };\n    \n    priority_queue<pair<string, int>, vector<pair<string, int> >, comp> q;\n        \n    TrieNode* root = new TrieNode;\n    TrieNode *curr;\n    AutocompleteSystem(vector<string> sentences, vector<int> times) {\n        //root = new TrieNode();\n        for (int i=0;i<sentences.size();i++){\n            insert(sentences[i], root, times[i]);\n        }\n        curr = root;\n    }\n    \n    \n    string s=\"\";\n    vector<string> input(char c) {\n        q = priority_queue<pair<string, int>, vector<pair<string, int> >, comp>();\n        if (c=='#'){\n            insert(s, root, 1);\n            s=\"\";\n            curr = root; //start searching from the beginning node for the next sentence\n            return {};\n        }\n        s += c;\n        if (curr && curr->child.count(c)){\n            curr = curr->child[c];\n        }else{\n            curr = NULL; //curr node is null so empty result for any further characters in current input \n            return {};\n        }\n        \n        if (curr->str != \"\") q.push({curr->str, curr->count});\n        for (auto& ele: curr->child){\n            dfs(ele.second);\n        }\n        \n        vector<string> res;\n        while (!q.empty() && res.size()<3){\n            res.push_back(q.top().first);\n            q.pop();\n        }\n        \n        return res;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111111111111"
    },
    {
      "id": 212054750,
      "lang": "cpp",
      "time": "2\u00a0months, 3\u00a0weeks",
      "timestamp": 1551641046,
      "status_display": "Accepted",
      "runtime": "356 ms",
      "url": "/submissions/detail/212054750/",
      "is_pending": "Not Pending",
      "title": "Design Search Autocomplete System",
      "memory": "114.8 MB",
      "code": "struct TrieNode {\n    unordered_map<char, TrieNode*> child;\n    string str;\n    int count;\n};\n\nclass AutocompleteSystem {\nprivate: \n    void insert(string s, TrieNode* root, int times){\n        TrieNode* curr = root;\n        for (int i=0;i<s.size();i++){\n            if (!curr->child.count(s[i]))\n                curr->child[s[i]] = new TrieNode();\n            curr = curr->child[s[i]];\n        }\n        curr->count += times;\n        curr->str = s;\n    }\n    \npublic:\n    void dfs(TrieNode* temp){\n        if (temp->str != \"\") q.push({temp->str, temp->count});\n        \n        for (auto& ele: temp->child){\n            dfs(ele.second);\n        }\n    }\n    \n    struct comp{\n        bool operator() (pair<string, int>& a, pair<string, int>& b){\n            return a.second<b.second || a.second==b.second && a.first>b.first;\n        }\n    };\n    \n    priority_queue<pair<string, int>, vector<pair<string, int> >, comp> q;\n        \n    TrieNode* root, *curr;\n    AutocompleteSystem(vector<string> sentences, vector<int> times) {\n        root = new TrieNode();\n        for (int i=0;i<sentences.size();i++){\n            insert(sentences[i], root, times[i]);\n        }\n        curr = root;\n    }\n    \n    \n    string s=\"\";\n    vector<string> input(char c) {\n        q = priority_queue<pair<string, int>, vector<pair<string, int> >, comp>();\n        if (c=='#'){\n            insert(s, root, 1);\n            s=\"\";\n            curr = root; //start searching from the beginning node for the next sentence\n            return {};\n        }\n        s += c;\n        if (curr && curr->child.count(c)){\n            curr = curr->child[c];\n        }else{\n            curr = NULL; //curr node is null so empty result for any further characters in current input \n            return {};\n        }\n        \n        if (curr->str != \"\") q.push({curr->str, curr->count});\n        for (auto& ele: curr->child){\n            dfs(ele.second);\n        }\n        \n        vector<string> res;\n        while (!q.empty() && res.size()<3){\n            res.push_back(q.top().first);\n            q.pop();\n        }\n        \n        return res;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111111111111"
    },
    {
      "id": 212054627,
      "lang": "cpp",
      "time": "2\u00a0months, 3\u00a0weeks",
      "timestamp": 1551641012,
      "status_display": "Accepted",
      "runtime": "384 ms",
      "url": "/submissions/detail/212054627/",
      "is_pending": "Not Pending",
      "title": "Design Search Autocomplete System",
      "memory": "114.4 MB",
      "code": "struct TrieNode {\n    unordered_map<char, TrieNode*> child;\n    string str;\n    int count;\n};\n\nclass AutocompleteSystem {\nprivate:\n    //TrieNode* root = new TrieNode();\n    \n    void insert(string& s, TrieNode* root, int times){\n        TrieNode* curr = root;\n        for (int i=0;i<s.size();i++){\n            if (!curr->child.count(s[i]))\n                curr->child[s[i]] = new TrieNode();\n            curr = curr->child[s[i]];\n        }\n        curr->count += times;\n        curr->str = s;\n    }\n    \npublic:\n    void dfs(TrieNode* temp){\n        if (temp->str != \"\") q.push({temp->str, temp->count});\n        \n        for (auto& ele: temp->child){\n            dfs(ele.second);\n        }\n    }\n    \n    struct comp{\n        bool operator() (pair<string, int>& a, pair<string, int>& b){\n            return a.second<b.second || a.second==b.second && a.first>b.first;\n        }\n    };\n    \n    priority_queue<pair<string, int>, vector<pair<string, int> >, comp> q;\n        \n    TrieNode* root, *curr;\n    AutocompleteSystem(vector<string> sentences, vector<int> times) {\n        root = new TrieNode();\n        for (int i=0;i<sentences.size();i++){\n            insert(sentences[i], root, times[i]);\n        }\n        curr = root;\n    }\n    \n    \n    string s=\"\";\n    vector<string> input(char c) {\n        q = priority_queue<pair<string, int>, vector<pair<string, int> >, comp>();\n        if (c=='#'){\n            insert(s, root, 1);\n            s=\"\";\n            curr = root; //start searching from the beginning node for the next sentence\n            return {};\n        }\n        s += c;\n        if (curr && curr->child.count(c)){\n            curr = curr->child[c];\n        }else{\n            curr = NULL; //curr node is null so empty result for any further characters in current input \n            return {};\n        }\n        \n        if (curr->str != \"\") q.push({curr->str, curr->count});\n        for (auto& ele: curr->child){\n            dfs(ele.second);\n        }\n        \n        vector<string> res;\n        while (!q.empty() && res.size()<3){\n            res.push_back(q.top().first);\n            q.pop();\n        }\n        \n        return res;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111111111111"
    },
    {
      "id": 212053794,
      "lang": "cpp",
      "time": "2\u00a0months, 3\u00a0weeks",
      "timestamp": 1551640775,
      "status_display": "Accepted",
      "runtime": "352 ms",
      "url": "/submissions/detail/212053794/",
      "is_pending": "Not Pending",
      "title": "Design Search Autocomplete System",
      "memory": "114.5 MB",
      "code": "class AutocompleteSystem {\n    \n    class TrieNode{\n        public:\n            unordered_map<char, TrieNode*> child;\n            string str;\n            int count;\n            TrieNode(): str(\"\"), count(0) {}\n    };\n    \n    void insert(string& s, TrieNode* root, int times){\n        TrieNode* curr = root;\n        for (int i=0;i<s.size();i++){\n            if (!curr->child.count(s[i]))\n                curr->child[s[i]] = new TrieNode();\n            curr = curr->child[s[i]];\n        }\n        curr->count += times;\n        curr->str = s;\n    }\n    \npublic:\n    void dfs(TrieNode* temp){\n        if (temp->str != \"\") q.push({temp->str, temp->count});\n        \n        for (auto& ele: temp->child){\n            dfs(ele.second);\n        }\n    }\n    \n    struct comp{\n        bool operator() (pair<string, int>& a, pair<string, int>& b){\n            return a.second<b.second || a.second==b.second && a.first>b.first;\n        }\n    };\n    \n    priority_queue<pair<string, int>, vector<pair<string, int> >, comp> q;\n        \n    TrieNode* root, *curr;\n    AutocompleteSystem(vector<string> sentences, vector<int> times) {\n        root = new TrieNode();\n        for (int i=0;i<sentences.size();i++){\n            insert(sentences[i], root, times[i]);\n        }\n        curr = root;\n    }\n    \n    \n    string s=\"\";\n    vector<string> input(char c) {\n        q = priority_queue<pair<string, int>, vector<pair<string, int> >, comp>();\n        if (c=='#'){\n            insert(s, root, 1);\n            s=\"\";\n            curr = root; //start searching from the beginning node for the next sentence\n            return {};\n        }\n        s += c;\n        if (curr && curr->child.count(c)){\n            curr = curr->child[c];\n        }else{\n            curr = NULL; //curr node is null so empty result for any further characters in current input \n            return {};\n        }\n        \n        if (curr->str != \"\") q.push({curr->str, curr->count});\n        for (auto& ele: curr->child){\n            dfs(ele.second);\n        }\n        \n        vector<string> res;\n        while (!q.empty() && res.size()<3){\n            res.push_back(q.top().first);\n            q.pop();\n        }\n        \n        return res;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111111111111"
    },
    {
      "id": 211573958,
      "lang": "cpp",
      "time": "2\u00a0months, 4\u00a0weeks",
      "timestamp": 1551466354,
      "status_display": "Accepted",
      "runtime": "92 ms",
      "url": "/submissions/detail/211573958/",
      "is_pending": "Not Pending",
      "title": "Replace Words",
      "memory": "44.6 MB",
      "code": "struct TrieNode {\n    unordered_map<char, TrieNode*> children;\n    bool isRoot;\n};\n\nclass Solution {\nprivate:\n    TrieNode* root = new TrieNode();\n    //root->isRoot = false;\npublic:\n    \n    void insert(string word) {\n        TrieNode* curr = root;\n        for(auto ch : word) {\n            if(curr->children.find(ch) == curr->children.end())\n                curr->children[ch] = new TrieNode();\n            curr = curr->children[ch];\n        }\n        curr->isRoot = true;\n    }\n    \n    string searchShortestPrefix(string word) {\n        string prefix = \"\";\n        bool prefixFound = false;\n        TrieNode* curr = root;\n        auto ch = word.begin();\n        while(curr->children[*ch] != NULL && !prefixFound) {\n            prefix += *ch;\n            if(curr->children[*ch]->isRoot)\n                prefixFound = true;\n            curr = curr->children[*ch];\n            ++ch;\n        }\n        if(prefixFound)\n            return prefix;\n        else\n            return word;\n    }\n    \n    string replaceWords(vector<string>& dict, string sentence) {\n        //store the words in setence in a vector\n        vector<string> words;\n        string holder;\n        string res = \"\";\n        stringstream iss(sentence); \n        // Read and print each word. \n        while (iss >> holder)\n            words.push_back(holder);\n        //insert all the roots into a Trie\n        for(int i=0; i<words.size(); i++)\n            cout << words[i] << \" \";\n        for(auto word : dict) {\n            insert(word);\n        }\n        for(auto word : words) {\n            string holder = searchShortestPrefix(word);\n            res += holder + \" \";\n        }\n        res.pop_back();\n        return res;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 211451599,
      "lang": "cpp",
      "time": "2\u00a0months, 4\u00a0weeks",
      "timestamp": 1551415694,
      "status_display": "Accepted",
      "runtime": "4 ms",
      "url": "/submissions/detail/211451599/",
      "is_pending": "Not Pending",
      "title": "Map Sum Pairs",
      "memory": "9.9 MB",
      "code": "struct TrieNode {\n    unordered_map<char, TrieNode*> children;\n    int value;\n};\n\nclass MapSum {\n    TrieNode* root;\n    unordered_map<string, int> map;\npublic:\n    /** Initialize your data structure here. */\n    MapSum() {\n        root = new TrieNode(); \n        root->value = 0;\n    }\n    \n    void insert(string key, int val) {\n        int delta = 0;\n        if(map.find(key) != map.end()) {\n            delta = val - map[key];\n            map[key] = val;\n        }\n        else {\n        map.insert(make_pair(key,val)); \n            delta = val;\n        }\n        TrieNode* curr = root;\n        for(auto ch : key) {\n            if(curr->children[ch] == NULL)\n                curr->children[ch] = new TrieNode();\n            curr = curr->children[ch];\n            curr->value += delta;\n        }\n    }\n    \n    int sum(string prefix) {\n        int res = 0;\n        TrieNode* curr = root;\n        for(auto ch : prefix) {\n            curr = curr->children[ch];\n            if(curr == NULL)\n                return 0;\n        }\n        return curr->value;\n    }\n};\n\n/**\n * Your MapSum object will be instantiated and called as such:\n * MapSum obj = new MapSum();\n * obj.insert(key,val);\n * int param_2 = obj.sum(prefix);\n */",
      "compare_result": "111111111111111111111111111111"
    },
    {
      "id": 211375206,
      "lang": "mysql",
      "time": "2\u00a0months, 4\u00a0weeks",
      "timestamp": 1551392081,
      "status_display": "Accepted",
      "runtime": "214 ms",
      "url": "/submissions/detail/211375206/",
      "is_pending": "Not Pending",
      "title": "Consecutive Available Seats",
      "memory": "N/A",
      "code": "# Write your MySQL query statement below\nselect distinct(a.seat_id) from cinema a, cinema b where abs(a.seat_id-b.seat_id)=1 and a.free=1 and b.free=1 order by a.seat_id",
      "compare_result": "1111111111111111"
    },
    {
      "id": 189845422,
      "lang": "java",
      "time": "6\u00a0months, 2\u00a0weeks",
      "timestamp": 1542336546,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/189845422/",
      "is_pending": "Not Pending",
      "title": "Plus One Linked List",
      "memory": "N/A",
      "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\n// Approach #1: Traverse to the end of the list and increment the digit by one.\n// Optimzation Approach #2: Use two pointers. Everytime you increment first pointer, increment second pointer by two.\n// Converges in O(n/2)..\n\n// This probelm cannot be approached as I told above.\n// So reverse the list, add 1 and reverse again ---> Not efficient!!!\n\n// How can you make it better ????\n// Either use recursion or Use a Stack.\n// Recursively change the digits and pass it.\n// EX : Think of 9999 +1 = 10000\n\n// O(n) space and O(n) time complecity solution.\nclass Solution {\n    public ListNode plusOne(ListNode head) {\n        if(head == null) //If it's a nulll, simply return that\n            return head;\n        \n        Stack<ListNode> st = new Stack<>();\n        ListNode dummy = head;//, prev = null;\n        while(dummy!=null) //Find teh last node in the list..\n        {\n            st.push(dummy);\n            //prev = dummy;\n            dummy = dummy.next;\n        }\n        \n        while(!st.isEmpty())\n        {\n            ListNode curr = st.pop();\n            curr.val+=1;\n            if(curr.val < 10)\n                return head; //No more change required.\n            else\n                curr.val = 0; //Set curr position to 0, we will add one to right bit. A Carry added.\n        }\n        \n        //If controll came here, there needs to be '1' added to MSB.\n        ListNode MSB = new ListNode(1);\n        MSB.next = head;\n        return MSB;\n    }\n}",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 189845339,
      "lang": "java",
      "time": "6\u00a0months, 2\u00a0weeks",
      "timestamp": 1542336520,
      "status_display": "Accepted",
      "runtime": "1 ms",
      "url": "/submissions/detail/189845339/",
      "is_pending": "Not Pending",
      "title": "Plus One Linked List",
      "memory": "N/A",
      "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\n// Approach #1: Traverse to the end of the list and increment the digit by one.\n// Optimzation Approach #2: Use two pointers. Everytime you increment first pointer, increment second pointer by two.\n// Converges in O(n/2)..\n\n// This probelm cannot be approached as I told above.\n// So reverse the list, add 1 and reverse again ---> Not efficient!!!\n\n// How can you make it better ????\n// Either use recursion or Use a Stack.\n// Recursively change the digits and pass it.\n// EX : Think of 9999 +1 = 10000\n\nclass Solution {\n    public ListNode plusOne(ListNode head) {\n        if(head == null) //If it's a nulll, simply return that\n            return head;\n        \n        Stack<ListNode> st = new Stack<>();\n        ListNode dummy = head;//, prev = null;\n        while(dummy!=null) //Find teh last node in the list..\n        {\n            st.push(dummy);\n            //prev = dummy;\n            dummy = dummy.next;\n        }\n        \n        while(!st.isEmpty())\n        {\n            ListNode curr = st.pop();\n            curr.val+=1;\n            if(curr.val < 10)\n                return head; //No more change required.\n            else\n                curr.val = 0; //Set curr position to 0, we will add one to right bit. A Carry added.\n        }\n        \n        //If controll came here, there needs to be '1' added to MSB.\n        ListNode MSB = new ListNode(1);\n        MSB.next = head;\n        return MSB;\n    }\n}",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 189843500,
      "lang": "java",
      "time": "6\u00a0months, 2\u00a0weeks",
      "timestamp": 1542335904,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/189843500/",
      "is_pending": "Not Pending",
      "title": "Plus One Linked List",
      "memory": "N/A",
      "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\n// Approach #1: Traverse to the end of the list and increment the digit by one.\n// Optimzation Approach #2: Use two pointers. Everytime you increment first pointer, increment second pointer by two.\n// Converges in O(n/2)..\n\nclass Solution {\n    public ListNode plusOne(ListNode head) {\n        if(head == null) //If it's a nulll, simply return that\n            return head;\n        \n        ListNode dummy = head, prev = null;\n        while(dummy!=null) //Find teh last node in the list..\n        {\n            prev = dummy;\n            dummy = dummy.next;\n        }\n        \n        prev.val+=1;\n        \n        return head;\n    }\n}",
      "compare_result": "111010001111110111111111111111011101111111111100001111111111111111111101111111111110100111111111111111111010"
    },
    {
      "id": 189842204,
      "lang": "java",
      "time": "6\u00a0months, 2\u00a0weeks",
      "timestamp": 1542335437,
      "status_display": "Accepted",
      "runtime": "8 ms",
      "url": "/submissions/detail/189842204/",
      "is_pending": "Not Pending",
      "title": "Minimum Add to Make Parentheses Valid",
      "memory": "N/A",
      "code": "// My approach: Maintain a Stack & keep pushing the elements onto stack.\n// If paranthesis match, remove such entry from stack.\n// return the count of paranthesis at the end.\n\nclass Solution {\n    public int minAddToMakeValid(String S) {\n        Stack<Character> st = new Stack<>();\n        if(S.length()==0) //The string is empty\n            return 0;\n        st.push(S.charAt(0));\n        for(int i=1; i < S.length();i++)\n        {\n            if(S.charAt(i) == ')' && !st.isEmpty() && st.peek() == '(')\n            {\n                st.pop();\n                continue;\n            }\n            else\n                st.push(S.charAt(i));\n        }\n        \n        return st.size();\n        \n        //return 0;\n    }\n}",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    }
  ],
  "has_next": true,
  "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22189842204%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222018-11-16T02%3A30%3A37.101764%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%22827856%22%7D%7D"
}