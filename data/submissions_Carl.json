{
  "submissions_dump": [
    {
      "id": 214875365,
      "lang": "cpp",
      "time": "2\u00a0months, 2\u00a0weeks",
      "timestamp": 1552610357,
      "status_display": "Accepted",
      "runtime": "4 ms",
      "url": "/submissions/detail/214875365/",
      "is_pending": "Not Pending",
      "title": "Number of 1 Bits",
      "memory": "8 MB",
      "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int res = 0;\n        while(n) {\n            n = n & n-1;\n            res++;\n        }\n        return res;\n    }\n};\n\n//n = 101 (5)\n//n-1 = 100 (4)\n    \n",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 214874175,
      "lang": "cpp",
      "time": "2\u00a0months, 2\u00a0weeks",
      "timestamp": 1552609950,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/214874175/",
      "is_pending": "Not Pending",
      "title": "Number of 1 Bits",
      "memory": "N/A",
      "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int bits = 0;\n        int mask = 1;\n        for(int i=0; i<32; i++) {\n            if((n & mask) != 0) {\n                bits++;                \n            }\n            mask <<= 1;\n        }\n        return bits;\n    }\n};",
      "compare_result": null
    },
    {
      "id": 214874156,
      "lang": "cpp",
      "time": "2\u00a0months, 2\u00a0weeks",
      "timestamp": 1552609943,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/214874156/",
      "is_pending": "Not Pending",
      "title": "Number of 1 Bits",
      "memory": "N/A",
      "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int bits = 0;\n        int mask = 1;\n        for(int i=0; i<31; i++) {\n            if((n & mask) != 0) {\n                bits++;                \n            }\n            mask <<= 1;\n        }\n        return bits;\n    }\n};",
      "compare_result": "1101111111111111111111111111111111001010101010101010101011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101001101100010011110110010110100"
    },
    {
      "id": 204104700,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548633426,
      "status_display": "Accepted",
      "runtime": "4 ms",
      "url": "/submissions/detail/204104700/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Vertical Order Traversal",
      "memory": "782.3 KB",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    queue<pair<TreeNode*, int>> Q;\n    unordered_map<int, vector<int>> V;\n    \n    vector<vector<int>> verticalOrder(TreeNode* root) {\n        if(root==NULL)\n        {\n            return vector<vector<int>> ();\n        }\n        \n        int maxLeft=0;\n        int maxRight=0;\n        Q.push({root, 0});\n        \n        vector<vector<int>> res;\n        \n        while(!Q.empty())\n        {\n            auto t = Q.front();\n            Q.pop();\n            if(t.first==NULL)\n                continue;\n            maxLeft = min(maxLeft, t.second);\n            maxRight = max(maxRight, t.second);\n            \n            V[t.second].push_back(t.first->val);\n            Q.push({t.first->left, t.second-1});\n            Q.push({t.first->right, t.second+1});\n            \n        }\n        \n        for(int i =maxLeft; i<=maxRight; i++)\n        {\n         //   if(V[i].size()!=0)\n            {\n                res.push_back(V[i]);\n            }\n        }\n        return res;\n            \n    }\n};",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 204104661,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548633416,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/204104661/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Vertical Order Traversal",
      "memory": "761.9 KB",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    queue<pair<TreeNode*, int>> Q;\n    unordered_map<int, vector<int>> V;\n    \n    vector<vector<int>> verticalOrder(TreeNode* root) {\n        if(root==NULL)\n        {\n            return vector<vector<int>> ();\n        }\n        \n        int maxLeft=0;\n        int maxRight=0;\n        Q.push({root, 0});\n        \n        vector<vector<int>> res;\n        \n        while(!Q.empty())\n        {\n            auto t = Q.front();\n            Q.pop();\n            if(t.first==NULL)\n                continue;\n            maxLeft = min(maxLeft, t.second);\n            maxRight = max(maxRight, t.second);\n            \n            V[t.second].push_back(t.first->val);\n            Q.push({t.first->left, t.second-1});\n            Q.push({t.first->right, t.second+1});\n            \n        }\n        \n        for(int i =maxLeft; i<=maxRight; i++)\n        {\n            if(V[i].size()!=0)\n            {\n                res.push_back(V[i]);\n            }\n        }\n        return res;\n            \n    }\n};",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 204077019,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548625915,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/204077019/",
      "is_pending": "Not Pending",
      "title": "Boundary of Binary Tree",
      "memory": "N/A",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> left,right, child;\n    \n    void rec(TreeNode* node, int level, bool leftBoundary, bool rightBoundary)\n    {\n        if(node==NULL)\n            return;\n        \n        if(leftBoundary)\n            left.push_back(node->val);\n        \n        if(!leftBoundary && rightBoundary)\n            right.push_back(node->val);\n        \n        \n        if(node->left == NULL && node->right==NULL)\n        {\n            child.push_back(node->val);\n            return;\n        }\n        \n        if(node->left == NULL || node->right == NULL)\n        {\n            rec(node->left, level+1, true & leftBoundary, true & rightBoundary);\n            rec(node->right, level+1, true & leftBoundary, true & rightBoundary);\n            return;\n        }\n        \n        \n        rec(node->left, level+1, true & leftBoundary, false);\n        rec(node->right, level+1, false, true & rightBoundary);\n    }\n    \n    void printVec(vector<int> V)\n    {\n        for(auto v:V)\n            cout<<v<<' ';\n        \n        cout<<endl;\n    }\n    \n    vector<int> boundaryOfBinaryTree(TreeNode* root) {\n        if(root == NULL)\n            return vector<int> ();\n        \n        rec(root,0,true, true);\n        \n        printVec(left);\n        printVec(right);\n        printVec(child);\n        \n        child.erase(child.begin());\n        if(child.size()>0)\n            child.pop_back();\n        \n        vector<int> res(left);\n       // if(res.back() != child.front())\n       //     res.push_back(child.front());\n        \n        res.insert(res.end(), child.begin(), child.end());\n        reverse(right.begin(), right.end());\n        \n       // if(res.back() != right.front())\n       //     res.push_back(right.front());\n            \n        res.insert(res.end(), right.begin(), right.end());\n       \n  //      if(res.size()>1)\n  //          res.pop_back();\n        return res;\n    }\n};",
      "compare_result": "011111111111111111100111111111000001111111010111111111111111111000000000000001111111111011111111111011111110111111111"
    },
    {
      "id": 204066273,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548622904,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/204066273/",
      "is_pending": "Not Pending",
      "title": "Boundary of Binary Tree",
      "memory": "N/A",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> left,right, child;\n    \n    void rec(TreeNode* node, int level, bool leftFlag, bool rightFlag)\n    {\n        if(node==NULL)\n            return;\n        \n        if(leftFlag)\n            left.push_back(node->val);\n        \n        if(rightFlag)\n            right.push_back(node->val);\n        \n        \n        if(node->left == NULL && node->right==NULL)\n            child.push_back(node->val);\n        \n        rec(node->left, level+1, true&leftFlag, false);\n        rec(node->right, level+1, false, true&rightFlag);\n    }\n    \n    void printVec(vector<int> V)\n    {\n        for(auto v:V)\n            cout<<v<<' ';\n        \n        cout<<endl;\n    }\n    \n    vector<int> boundaryOfBinaryTree(TreeNode* root) {\n        if(root == NULL)\n            return vector<int> ();\n        \n        rec(root,0,true, true);\n        \n        printVec(left);\n        printVec(right);\n        printVec(child);\n        \n        vector<int> res(left);\n        if(res.back() != child.front())\n            res.push_back(child.front());\n        \n        res.insert(res.end(), child.begin()+1, child.end());\n        reverse(right.begin(), right.end());\n        \n        if(res.back() != right.front())\n            res.push_back(right.front());\n            \n        res.insert(res.end(), right.begin()+1, right.end());\n       \n        if(res.size()>1)\n            res.pop_back();\n        return res;\n    }\n};",
      "compare_result": "111011111110111111111111111010010111111111111011001011000011000010011010010110011111111111101101001000101000111101001"
    },
    {
      "id": 203860174,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548545728,
      "status_display": "Accepted",
      "runtime": "28 ms",
      "url": "/submissions/detail/203860174/",
      "is_pending": "Not Pending",
      "title": "Range Sum Query 2D - Mutable",
      "memory": "11.8 MB",
      "code": "class NumMatrix {\npublic:\n    struct TreeNode\n    {\n        int sum;\n        int xStart, xEnd, yStart, yEnd;\n        vector<TreeNode*> child;\n        TreeNode(int sx, int ex, int sy, int ey, int s=0):xStart(sx), xEnd(ex), yStart(sy), yEnd(ey), sum(s)\n        {\n            child = vector<TreeNode*> (4);\n        }\n    }*head;\n    vector<vector<int>> N;\n    \n    int getVal(TreeNode* node)\n    {\n        if(node == NULL)\n            return 0;\n        \n        return node->sum;\n    }\n    \n    TreeNode* createNode(vector<vector<int>>& N, int sx, int ex, int sy, int ey)\n    {\n        if(sx>ex || sy>ey)\n            return NULL;\n        \n        if(sx==ex && sy == ey)\n        {\n            TreeNode* node= new TreeNode(sx,ex,sy,ey,N[sx][sy]);\n            return node;\n        }\n        \n        int midx = (sx+ex)/2;\n        int midy = (sy+ey)/2;\n        \n        TreeNode* node = new TreeNode(sx, ex, sy, ey);\n        node->child[0] = createNode(N, sx, midx, sy, midy);\n        node->child[1] = createNode(N, sx, midx, midy+1, ey);\n        node->child[2] = createNode(N, midx+1, ex, sy, midy);\n        node->child[3] = createNode(N, midx+1, ex, midy+1, ey);\n        \n        node->sum = 0;\n        for(int i=0;i<4;i++)\n            node->sum += getVal(node->child[i]);\n        \n        return node;\n    }\n    \n    int getSum(TreeNode* node, int sx, int ex, int sy, int ey)\n    {\n        if(node == NULL)\n            return 0;\n        \n  //      cout<<\"searching \"<<sx<<'-'<<ex <<' '<<sy<<'-'<<ey<<endl;\n        if(ex < node->xStart || sx > node->xEnd || ey < node->yStart || sy > node->yEnd)\n            return 0;\n        \n        if(sx == node->xStart && ex == node->xEnd && sy == node->yStart && ey == node->yEnd)\n        {\n            return node->sum;\n        }\n        \n        int midx = (node->xStart + node->xEnd) / 2;\n        int midy = (node->yStart + node->yEnd) / 2;\n        /*\n        if(s >mid)\n        {\n            // search on right\n            return getSum(node->right, s, e);\n        }\n        \n        if(e <= mid)\n        {\n            return getSum(node->left, s, e);\n        }\n        */\n        return getSum(node->child[0], max(sx,node->xStart) ,min(midx, ex), max(sy,node->yStart), min(midy, ey))\n             + getSum(node->child[1], max(sx,node->xStart) ,min(midx, ex), max(midy+1, sy), min(ey, node->yEnd))\n             + getSum(node->child[2], max(midx+1, sx) ,min(ex, node->xEnd), max(sy,node->yStart), min(midy, ey))\n             + getSum(node->child[3], max(midx+1, sx) ,min(ex, node->xEnd), max(midy+1, sy), min(ey, node->yEnd));\n             \n            \n    }\n    \n    void updateNode(TreeNode* node, int xPos, int yPos, int diff)\n    {\n        if(node == NULL)\n            return;\n        \n        if(xPos >= node->xStart && xPos <= node->xEnd && yPos >= node->yStart && yPos <= node->yEnd)\n            node->sum += diff;\n        else\n             return;\n    //    cout<<\"updating \"<<node->xStart <<node->xEnd<<node->yStart<<node->yEnd<<node->sum<<endl;\n      //  int midx = (node->xStart + node->xEnd) / 2;\n      //  int midy = (node->yStart + node->yEnd) / 2;\n        \n       for(int i=0;i<4;i++)\n            updateNode(node->child[i], xPos, yPos, diff);\n    }\n    \n    NumMatrix(vector<vector<int>> matrix): N(matrix){\n        if(matrix.size()==0 || matrix[0].size()==0)\n        {    head = NULL;\n            return;\n        }\n        head = createNode(matrix, 0, matrix.size()-1, 0, matrix[0].size()-1);\n    }\n    \n    void update(int row, int col, int val) {\n        updateNode(head, row, col, val - N[row][col]);\n        N[row][col]=val;\n  //      cout<<endl;\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return getSum(head, row1, row2, col1, col2);\n        \n    }\n};\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = new NumMatrix(matrix);\n * obj.update(row,col,val);\n * int param_2 = obj.sumRegion(row1,col1,row2,col2);\n */",
      "compare_result": "11111111111111111"
    },
    {
      "id": 203858518,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548545260,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/203858518/",
      "is_pending": "Not Pending",
      "title": "Range Sum Query 2D - Mutable",
      "memory": "N/A",
      "code": "class NumMatrix {\npublic:\n    struct TreeNode\n    {\n        int sum;\n        int xStart, xEnd, yStart, yEnd;\n        vector<TreeNode*> child;\n        TreeNode(int sx, int ex, int sy, int ey, int s=0):xStart(sx), xEnd(ex), yStart(sy), yEnd(ey), sum(s)\n        {\n            child = vector<TreeNode*> (4);\n        }\n    }*head;\n    vector<vector<int>> N;\n    \n    int getVal(TreeNode* node)\n    {\n        if(node == NULL)\n            return 0;\n        \n        return node->sum;\n    }\n    \n    TreeNode* createNode(vector<vector<int>>& N, int sx, int ex, int sy, int ey)\n    {\n        if(sx>ex || sy>ey)\n            return NULL;\n        \n        if(sx==ex && sy == ey)\n        {\n            TreeNode* node= new TreeNode(sx,ex,sy,ey,N[sx][sy]);\n            return node;\n        }\n        \n        int midx = (sx+ex)/2;\n        int midy = (sy+ey)/2;\n        \n        TreeNode* node = new TreeNode(sx, ex, sy, ey);\n        node->child[0] = createNode(N, sx, midx, sy, midy);\n        node->child[1] = createNode(N, sx, midx, midy+1, ey);\n        node->child[2] = createNode(N, midx+1, ex, sy, midy);\n        node->child[3] = createNode(N, midx+1, ex, midy+1, ey);\n        \n        node->sum = 0;\n        for(int i=0;i<4;i++)\n            node->sum += getVal(node->child[i]);\n        \n        return node;\n    }\n    \n    int getSum(TreeNode* node, int sx, int ex, int sy, int ey)\n    {\n        if(node == NULL)\n            return 0;\n        \n  //      cout<<\"searching \"<<sx<<'-'<<ex <<' '<<sy<<'-'<<ey<<endl;\n        if(ex < node->xStart || sx > node->xEnd || ey < node->yStart || sy > node->yEnd)\n            return 0;\n        \n        if(sx == node->xStart && ex == node->xEnd && sy == node->yStart && ey == node->yEnd)\n        {\n            return node->sum;\n        }\n        \n        int midx = (node->xStart + node->xEnd) / 2;\n        int midy = (node->yStart + node->yEnd) / 2;\n        /*\n        if(s >mid)\n        {\n            // search on right\n            return getSum(node->right, s, e);\n        }\n        \n        if(e <= mid)\n        {\n            return getSum(node->left, s, e);\n        }\n        */\n        return getSum(node->child[0], max(sx,node->xStart) ,min(midx, ex), max(sy,node->yStart), min(midy, ey))\n             + getSum(node->child[1], max(sx,node->xStart) ,min(midx, ex), max(midy+1, sy), min(ey, node->yEnd))\n             + getSum(node->child[2], max(midx+1, sx) ,min(ex, node->xEnd), max(sy,node->yStart), min(midy, ey))\n             + getSum(node->child[3], max(midx+1, sx) ,min(ex, node->xEnd), max(midy+1, sy), min(ey, node->yEnd));\n             \n            \n    }\n    \n    void updateNode(TreeNode* node, int xPos, int yPos, int diff)\n    {\n        if(node == NULL)\n            return;\n        \n        if(xPos >= node->xStart && xPos <= node->xEnd && yPos >= node->yStart && yPos <= node->yEnd)\n            node->sum += diff;\n        else\n             return;\n        \n      //  int midx = (node->xStart + node->xEnd) / 2;\n      //  int midy = (node->yStart + node->yEnd) / 2;\n        \n       for(int i=0;i<4;i++)\n            updateNode(node->child[i], xPos, yPos, diff);\n    }\n    \n    NumMatrix(vector<vector<int>> matrix): N(matrix){\n        if(matrix.size()==0 || matrix[0].size()==0)\n        {    head = NULL;\n            return;\n        }\n        head = createNode(matrix, 0, matrix.size()-1, 0, matrix[0].size()-1);\n    }\n    \n    void update(int row, int col, int val) {\n        updateNode(head, row, col, val - N[row][col]);\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return getSum(head, row1, row2, col1, col2);\n        \n    }\n};\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = new NumMatrix(matrix);\n * obj.update(row,col,val);\n * int param_2 = obj.sumRegion(row1,col1,row2,col2);\n */",
      "compare_result": "11111010101111110"
    },
    {
      "id": 203858244,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548545187,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/203858244/",
      "is_pending": "Not Pending",
      "title": "Range Sum Query 2D - Mutable",
      "memory": "N/A",
      "code": "class NumMatrix {\npublic:\n    struct TreeNode\n    {\n        int sum;\n        int xStart, xEnd, yStart, yEnd;\n        vector<TreeNode*> child;\n        TreeNode(int sx, int ex, int sy, int ey, int s=0):xStart(sx), xEnd(ex), yStart(sy), yEnd(ey), sum(s)\n        {\n            child = vector<TreeNode*> (4);\n        }\n    }*head;\n    vector<vector<int>> N;\n    \n    int getVal(TreeNode* node)\n    {\n        if(node == NULL)\n            return 0;\n        \n        return node->sum;\n    }\n    \n    TreeNode* createNode(vector<vector<int>>& N, int sx, int ex, int sy, int ey)\n    {\n        if(sx>ex || sy>ey)\n            return NULL;\n        \n        if(sx==ex && sy == ey)\n        {\n            TreeNode* node= new TreeNode(sx,ex,sy,ey,N[sx][sy]);\n            return node;\n        }\n        \n        int midx = (sx+ex)/2;\n        int midy = (sy+ey)/2;\n        \n        TreeNode* node = new TreeNode(sx, ex, sy, ey);\n        node->child[0] = createNode(N, sx, midx, sy, midy);\n        node->child[1] = createNode(N, sx, midx, midy+1, ey);\n        node->child[2] = createNode(N, midx+1, ex, sy, midy);\n        node->child[3] = createNode(N, midx+1, ex, midy+1, ey);\n        \n        node->sum = 0;\n        for(int i=0;i<4;i++)\n            node->sum += getVal(node->child[i]);\n        \n        return node;\n    }\n    \n    int getSum(TreeNode* node, int sx, int ex, int sy, int ey)\n    {\n        if(node == NULL)\n            return 0;\n        \n  //      cout<<\"searching \"<<sx<<'-'<<ex <<' '<<sy<<'-'<<ey<<endl;\n        if(ex < node->xStart || sx > node->xEnd || ey < node->yStart || sy > node->yEnd)\n            return 0;\n        \n        if(sx == node->xStart && ex == node->xEnd && sy == node->yStart && ey == node->yEnd)\n        {\n            return node->sum;\n        }\n        \n        int midx = (node->xStart + node->xEnd) / 2;\n        int midy = (node->yStart + node->yEnd) / 2;\n        /*\n        if(s >mid)\n        {\n            // search on right\n            return getSum(node->right, s, e);\n        }\n        \n        if(e <= mid)\n        {\n            return getSum(node->left, s, e);\n        }\n        */\n        return getSum(node->child[0], max(sx,node->xStart) ,min(midx, ex), max(sy,node->yStart), min(midy, ey))\n             + getSum(node->child[1], max(sx,node->xStart) ,min(midx, ex), max(midy+1, sy), min(ey, node->yEnd))\n             + getSum(node->child[2], max(midx+1, sx) ,min(ex, node->xEnd), max(sy,node->yStart), min(midy, ey))\n             + getSum(node->child[3], max(midx+1, sx) ,min(ex, node->xEnd), max(midy+1, sy), min(ey, node->yEnd));\n             \n            \n    }\n    \n    void updateNode(TreeNode* node, int xPos, int yPos, int diff)\n    {\n        if(node == NULL)\n            return;\n        \n        if(xPos >= node->xStart && xPos <= node->xEnd && yPos >= node->yStart && yPos <= node->yEnd)\n            node->sum += diff;\n        else\n             return;\n        \n      //  int midx = (node->xStart + node->xEnd) / 2;\n      //  int midy = (node->yStart + node->yEnd) / 2;\n        \n       for(int i=0;i<4;i++)\n            updateNode(node->child[i], xPos, yPos, diff);\n    }\n    \n    NumMatrix(vector<vector<int>> matrix): N(matrix){\n        head = createNode(matrix, 0, matrix.size()-1, 0, matrix[0].size()-1);\n    }\n    \n    void update(int row, int col, int val) {\n        updateNode(head, row, col, val - N[row][col]);\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return getSum(head, row1, row2, col1, col2);\n        \n    }\n};\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = new NumMatrix(matrix);\n * obj.update(row,col,val);\n * int param_2 = obj.sumRegion(row1,col1,row2,col2);\n */",
      "compare_result": null
    },
    {
      "id": 203681476,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548463986,
      "status_display": "Accepted",
      "runtime": "220 ms",
      "url": "/submissions/detail/203681476/",
      "is_pending": "Not Pending",
      "title": "Design Search Autocomplete System",
      "memory": "64.6 MB",
      "code": "\n    struct heapData\n    {\n        int count;\n        string sent;\n        //int sentIndx;\n        \n        \n        \n        bool operator< (const heapData& h) const\n        {\n            if(count != h.count)\n                return count > h.count;\n            \n            return sent < h.sent;\n        }\n        \n    };\n    \n    struct TrieNode\n    {\n        char c;\n        priority_queue<heapData> minHeap;\n        vector<TrieNode*> next;\n        \n        TrieNode(char x):c(x)\n        {\n            next = vector<TrieNode*> (27, NULL);\n        }\n        \n    };\n\nclass AutocompleteSystem {\npublic:\n    \n    \n    int getCharInd(char x)\n    {\n        if(isalpha(x))\n            return x-'a';\n        \n        if(x == ' ')\n            return 26;\n        \n        return 27;\n    }\n    \n    vector<string> S;\n    TrieNode* head = NULL;\n    TrieNode* tempNode = NULL;\n    string currentString;\n    \n    void insertSent(string &str, int count, int ind)\n    {\n  //      cout<<\"insert\"<<str<<endl;\n        TrieNode* currNode = head;\n        for(auto c:str)\n        {\n            if(currNode->next[getCharInd(c)] == NULL)\n            {\n                currNode->next[getCharInd(c)] = new TrieNode(c);\n            }\n            \n            currNode = currNode->next[getCharInd(c)];\n        //    cout<<currNode->c<<endl;\n            priority_queue<heapData> tempHeap;\n            bool found = false;\n            while(!currNode->minHeap.empty())\n            {\n                if(str == currNode->minHeap.top().sent)\n                {\n                    found = true;\n      //              cout<<\"found\"<<currNode->minHeap.top().count <<endl;\n                    heapData temp;\n                    temp.count = currNode->minHeap.top().count + count;\n                    temp.sent = str;\n                    tempHeap.push(temp);\n                }\n                else\n                    tempHeap.push(currNode->minHeap.top());\n                \n                currNode->minHeap.pop();\n            }\n            currNode->minHeap = tempHeap;\n            if(!found)\n            {\n    //            cout<<\"not found\"<<str<<endl;\n                heapData temp;\n                temp.count = count;\n                temp.sent = str;\n                currNode->minHeap.push(temp);\n            }\n        /*    if(currNode->minHeap.size() > 3)\n            {\n                cout<<\"pop\"<<currNode->minHeap.top().sent<<' '<<currNode->minHeap.top().count<<endl;\n                currNode->minHeap.pop();\n            }\n          */  \n            \n        }\n        \n    }\n    \n    vector<string> getStrings(TrieNode* node)\n    {\n        priority_queue<heapData> tempHeap;\n        vector<string> res;\n   //     cout<<\"size=\"<<node->minHeap.size()<<endl;\n        \n        while(!node->minHeap.empty())\n        {\n            res.push_back(node->minHeap.top().sent);\n            tempHeap.push(node->minHeap.top());\n    //        cout<<node->minHeap.top().count<<endl;\n            node->minHeap.pop();\n            \n        }\n        \n        node->minHeap = tempHeap;\n        reverse(res.begin(), res.end());\n        int i =min(3, (int)res.size());\n        return vector<string> (res.begin(), res.begin()+i);\n    }\n    \n    AutocompleteSystem(vector<string> sentences, vector<int> times) \n    {\n         for(int i = 0; i < sentences.size(); i++)\n            {\n                S.push_back(sentences[i]);\n            }\n        head = new TrieNode(0);\n        tempNode = head;\n        \n        for(int i = 0; i < sentences.size(); i++)\n        {\n        //    S.push_back(sentences[i]);\n            insertSent(sentences[i], times[i], i);\n        }\n    }\n    \n    vector<string> input(char c) {\n        if(getCharInd(c) == 27)\n        {\n            tempNode = head;\n            \n            insertSent(currentString, 1, S.size());\n            S.push_back(currentString);\n            currentString.clear();\n            return vector<string> ();\n        }\n        \n        if(tempNode == NULL || tempNode->next[getCharInd(c)] == NULL)\n        {\n            currentString += c;\n            tempNode = NULL;\n            return vector<string> ();\n        }\n        \n        currentString += c;\n        \n        tempNode = tempNode->next[getCharInd(c)];\n        \n        return getStrings(tempNode);\n    }\n};\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * AutocompleteSystem obj = new AutocompleteSystem(sentences, times);\n * vector<string> param_1 = obj.input(c);\n */",
      "compare_result": "1111111111111111111111111111111111111111111"
    },
    {
      "id": 203673944,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548460728,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/203673944/",
      "is_pending": "Not Pending",
      "title": "Design Search Autocomplete System",
      "memory": "N/A",
      "code": "\n    struct heapData\n    {\n        int count;\n        string sent;\n        //int sentIndx;\n        \n        \n        \n        bool operator< (const heapData& h) const\n        {\n            if(count != h.count)\n                return count > h.count;\n            \n            return sent < h.sent;\n        }\n        \n    };\n    \n    struct TrieNode\n    {\n        char c;\n        priority_queue<heapData> minHeap;\n        TrieNode* next[27];\n        \n        TrieNode(char x):c(x)\n        {}\n        \n    };\n\nclass AutocompleteSystem {\npublic:\n    \n    \n    int getCharInd(char x)\n    {\n        if(isalpha(x))\n            return x-'a';\n        \n        if(x == ' ')\n            return 26;\n        \n        return 27;\n    }\n    \n    vector<string> S;\n    TrieNode* head = NULL;\n    TrieNode* tempNode = NULL;\n    string currentString;\n    \n    void insertSent(string &str, int count, int ind)\n    {\n        TrieNode* currNode = head;\n        for(auto c:str)\n        {\n            if(currNode->next[getCharInd(c)] == NULL)\n            {\n                currNode->next[getCharInd(c)] = new TrieNode(c);\n            }\n            \n            currNode = currNode->next[getCharInd(c)];\n            heapData temp;\n            temp.count = count;\n            temp.sent = str;\n            currNode->minHeap.push(temp);\n            if(currNode->minHeap.size() > 3)\n            {\n                currNode->minHeap.pop();\n            }\n            \n            \n        }\n        \n    }\n    \n    vector<string> getStrings(TrieNode* node)\n    {\n        priority_queue<heapData> tempHeap;\n        vector<string> res;\n        \n        while(!node->minHeap.empty())\n        {\n            res.push_back(node->minHeap.top().sent);\n            tempHeap.push(node->minHeap.top());\n            node->minHeap.pop();\n        }\n        \n        node->minHeap = tempHeap;\n        reverse(res.begin(), res.end());\n        return res;\n    }\n    \n    AutocompleteSystem(vector<string> sentences, vector<int> times) \n    {\n         for(int i = 0; i < sentences.size(); i++)\n        {\n            S.push_back(sentences[i]);\n        }\n        head = new TrieNode(0);\n        tempNode = head;\n        \n        for(int i = 0; i < sentences.size(); i++)\n        {\n        //    S.push_back(sentences[i]);\n            insertSent(sentences[i], times[i], i);\n        }\n    }\n    \n    vector<string> input(char c) {\n        if(getCharInd(c) == 27)\n        {\n            tempNode = head;\n            insertSent(currentString, 1, S.size());\n            S.push_back(currentString);\n            \n            return vector<string> ();\n        }\n        \n        if(tempNode == NULL || tempNode->next[getCharInd(c)] == NULL)\n        {\n            currentString += c;\n            tempNode = NULL;\n            return vector<string> ();\n        }\n        \n        currentString += c;\n        \n        tempNode = tempNode->next[getCharInd(c)];\n        \n        return getStrings(tempNode);\n    }\n};\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * AutocompleteSystem obj = new AutocompleteSystem(sentences, times);\n * vector<string> param_1 = obj.input(c);\n */",
      "compare_result": null
    },
    {
      "id": 203472552,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548374327,
      "status_display": "Accepted",
      "runtime": "12 ms",
      "url": "/submissions/detail/203472552/",
      "is_pending": "Not Pending",
      "title": "Robot Room Cleaner",
      "memory": "1.6 MB",
      "code": "/**\n * // This is the robot's control interface.\n * // You should not implement it, or speculate about its implementation\n * class Robot {\n *   public:\n *     // Returns true if the cell in front is open and robot moves into the cell.\n *     // Returns false if the cell in front is blocked and robot stays in the current cell.\n *     bool move();\n *\n *     // Robot will stay in the same cell after calling turnLeft/turnRight.\n *     // Each turn will be 90 degrees.\n *     void turnLeft();\n *     void turnRight();\n *\n *     // Clean the current cell.\n *     void clean();\n * };\n */\nclass Solution {\npublic:\n    \n    int currDir;\n    unordered_set<string> vis;\n     \n    vector<vector<int>> dir = {{-1,0}, {0, -1}, {1, 0}, {0, 1}};\n    \n    string getName(int x, int y)\n    {\n        return ('R' + to_string(x) + 'C' + to_string(y));\n    }\n    \n    int getLeft(int dir)\n    {\n        return (dir+1)%4;\n    }\n    \n    int getRight(int dir)\n    {\n        return (dir+3)%4;\n    }\n    \n    void left(Robot& r)\n    {\n        currDir = getLeft(currDir);\n        r.turnLeft();\n    }\n    \n    void right(Robot& r)\n    {\n        currDir = getRight(currDir);\n        r.turnRight();\n    }\n    \n    void goToRight(Robot& r, int dir)\n    {\n        while(currDir != getRight(dir))\n        {\n       //     cout<<\"turning right\\n\";\n            r.turnRight();\n            currDir = getRight(currDir);\n        }\n    }\n    \n    void goToLeft(Robot& r, int dir)\n    {\n        while(currDir != getLeft(dir))\n        {\n      //      cout<<\"turning left\\n\";\n            r.turnLeft();\n            currDir = getLeft(currDir);\n        }\n    }\n    \n    \n    void goBack(Robot& r, int dir)\n    {\n        while(currDir != (dir+2)%4)\n        {\n         //    cout<<\"turning left to reverse\\n\";\n            r.turnLeft();\n            currDir = getLeft(currDir);\n        }\n    }\n    \n    \n    void traverse(Robot& robot, int x, int y)\n    {\n        auto name = getName(x,y);\n        vis.insert(name);\n    //    cout<<x<<' '<<y<<endl;\n        int tempDir = currDir;\n        robot.clean();\n        // go straight\n        if(vis.find(getName(x+dir[currDir][0], y+dir[currDir][1])) == vis.end())\n        {\n            if(robot.move())\n            {\n      //          cout<<\"move\\n\";\n                traverse(robot, x+dir[currDir][0], y+dir[currDir][1]);\n            }\n        }\n        \n        // turn to right of tempDir\n        goToRight(robot, tempDir);\n    //    cout<<currDir<<' '<<x+dir[currDir][0]<<','<< y+dir[currDir][1]<<endl;\n        // try to go right\n        if(vis.find(getName(x+dir[currDir][0], y+dir[currDir][1])) == vis.end())\n        {\n      //      cout<<\"not yet covered\\n\";\n            if(robot.move())\n            {\n      //          cout<<\"move\\n\";\n                traverse(robot, x+dir[currDir][0], y+dir[currDir][1]);\n            }\n        }\n        \n        // turn to left of tempDir\n        goToLeft(robot, tempDir);\n        // try to go right\n        if(vis.find(getName(x+dir[currDir][0], y+dir[currDir][1])) == vis.end())\n        {\n            if(robot.move())\n            {\n      //          cout<<\"move\\n\";\n                traverse(robot, x+dir[currDir][0], y+dir[currDir][1]);\n            }\n        }\n        \n        goBack(robot, tempDir);\n        robot.move();\n   //     cout<<\"move\\n\";\n        if(vis.find(getName(x+dir[currDir][0], y+dir[currDir][1])) == vis.end())\n            traverse(robot, x+dir[currDir][0], y+dir[currDir][1]);\n        \n        \n    }\n    \n    \n    void cleanRoom(Robot& robot) {\n        vis.clear();\n        currDir = 0;\n        traverse(robot, 0, 0);\n    }\n};",
      "compare_result": "11111111111111111111111111111"
    },
    {
      "id": 203470563,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548373551,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/203470563/",
      "is_pending": "Not Pending",
      "title": "Robot Room Cleaner",
      "memory": "N/A",
      "code": "/**\n * // This is the robot's control interface.\n * // You should not implement it, or speculate about its implementation\n * class Robot {\n *   public:\n *     // Returns true if the cell in front is open and robot moves into the cell.\n *     // Returns false if the cell in front is blocked and robot stays in the current cell.\n *     bool move();\n *\n *     // Robot will stay in the same cell after calling turnLeft/turnRight.\n *     // Each turn will be 90 degrees.\n *     void turnLeft();\n *     void turnRight();\n *\n *     // Clean the current cell.\n *     void clean();\n * };\n */\nclass Solution {\npublic:\n    \n    int currDir;\n    unordered_set<string> vis;\n     \n    vector<vector<int>> dir = {{-1,0}, {0, -1}, {1, 0}, {0, 1}};\n    \n    string getName(int x, int y)\n    {\n        return ('R' + to_string(x) + 'C' + to_string(y));\n    }\n    \n    int getLeft(int dir)\n    {\n        return (dir+1)%4;\n    }\n    \n    int getRight(int dir)\n    {\n        return (dir+3)%4;\n    }\n    \n    void left(Robot& r)\n    {\n        currDir = getLeft(currDir);\n        r.turnLeft();\n    }\n    \n    void right(Robot& r)\n    {\n        currDir = getRight(currDir);\n        r.turnRight();\n    }\n    \n    void goToRight(Robot& r, int dir)\n    {\n        while(currDir != getRight(dir))\n        {\n  //          cout<<\"turning right\\n\";\n            r.turnRight();\n            currDir = getRight(currDir);\n        }\n    }\n    \n    void goToLeft(Robot& r, int dir)\n    {\n        while(currDir != getLeft(dir))\n        {\n  //          cout<<\"turning left\\n\";\n            r.turnLeft();\n            currDir = getLeft(currDir);\n        }\n    }\n    \n    \n    void goBack(Robot& r, int dir)\n    {\n        while(currDir != (dir+2)%4)\n        {\n  //           cout<<\"turning left to reverse\\n\";\n            r.turnLeft();\n            currDir = getLeft(currDir);\n        }\n    }\n    \n    \n    void traverse(Robot& robot, int x, int y)\n    {\n        auto name = getName(x,y);\n        vis.insert(name);\n   //     cout<<x<<' '<<y<<endl;\n        int tempDir = currDir;\n        robot.clean();\n        // go straight\n        if(vis.find(getName(x+dir[currDir][0], y+dir[currDir][1])) == vis.end())\n        {\n            if(robot.move())\n            {\n   //             cout<<\"move\\n\";\n                traverse(robot, x+dir[currDir][0], y+dir[currDir][1]);\n            }\n        }\n        \n        // turn to right of tempDir\n        goToRight(robot, tempDir);\n        // try to go right\n        if(vis.find(getName(x+dir[currDir][0], y+dir[currDir][1])) == vis.end())\n        {\n            if(robot.move())\n            {\n  //              cout<<\"move\\n\";\n                traverse(robot, x+dir[currDir][0], y+dir[currDir][1]);\n            }\n        }\n        \n        // turn to left of tempDir\n        goToLeft(robot, tempDir);\n        // try to go right\n        if(vis.find(getName(x+dir[currDir][0], y+dir[currDir][1])) == vis.end())\n        {\n            if(robot.move())\n            {\n //               cout<<\"move\\n\";\n                traverse(robot, x+dir[currDir][0], y+dir[currDir][1]);\n            }\n        }\n        \n        goBack(robot, tempDir);\n        robot.move();\n//        cout<<\"move\\n\";\n        \n        \n    }\n    \n    \n    void cleanRoom(Robot& robot) {\n        currDir = 0;\n        traverse(robot, 0, 0);\n    }\n};",
      "compare_result": "11011100111011011101111111111"
    },
    {
      "id": 203306435,
      "lang": "cpp",
      "time": "4\u00a0months",
      "timestamp": 1548304537,
      "status_display": "Accepted",
      "runtime": "172 ms",
      "url": "/submissions/detail/203306435/",
      "is_pending": "Not Pending",
      "title": "K Empty Slots",
      "memory": "1.5 MB",
      "code": "class Solution {\npublic:\n    int kEmptySlots(vector<int>& F, int k) {\n        if(F.size()<2)\n            return -1;\n        \n    //    if(k==0)\n    //        return 2;\n        \n        deque<int> D;\n        vector<int> T(F.size()+2);\n        \n        for(int i=0 ; i < F.size() ; i++)\n        {\n            T[F[i]] = i+1;\n            \n        }\n        \n    //    for(auto t:T)\n    //        cout<<t<<endl;\n        \n          \n        int res=INT_MAX;\n        \n        for(int i=3 ; i <= F.size() ; i++)\n        {\n            if(i>k+2 && !D.empty())\n            {\n                //evict last\n                if(D.back() == i-k-1)\n                    D.pop_back();\n            }\n            \n            // insert i-1\n            while(!D.empty() && T[D.front()] > T[i-1])\n            {\n                D.pop_front();\n            }\n            \n            if(k!=0)\n                D.push_front(i-1);\n            \n            if(i>k+1)\n            {\n                int maxBoundary = max(T[i], T[i-k-1]);\n                //cout<<i<<' '<<maxBoundary<<' '<<D.back()<<' '<<D.front()<<endl;\n                if(D.empty()  || maxBoundary < T[D.back()])\n                    res = min(res, maxBoundary);\n                                      \n            }\n        }\n        \n        return res==INT_MAX?-1:res;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 200765884,
      "lang": "java",
      "time": "4\u00a0months, 2\u00a0weeks",
      "timestamp": 1547323672,
      "status_display": "Accepted",
      "runtime": "30 ms",
      "url": "/submissions/detail/200765884/",
      "is_pending": "Not Pending",
      "title": "Sqrt(x)",
      "memory": "27.1 MB",
      "code": "class Solution {\n    public int mySqrt(int x) {\n        int lo=1;\n        int hi = x;\n        int ans=0; \n        while(hi>=lo)\n        {\n            int mid=(lo+hi)/2;\n            if(mid<=x/mid)\n            {\n                ans=mid;\n                lo=mid+1;\n            }\n            else\n            {\n                hi=mid-1;\n            }\n        }\n        return ans;\n        \n    }\n}",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 200765696,
      "lang": "java",
      "time": "4\u00a0months, 2\u00a0weeks",
      "timestamp": 1547323602,
      "status_display": "Time Limit Exceeded",
      "runtime": "N/A",
      "url": "/submissions/detail/200765696/",
      "is_pending": "Not Pending",
      "title": "Sqrt(x)",
      "memory": "N/A",
      "code": "class Solution {\n    public int mySqrt(int x) {\n        int lo=1;\n        int hi = x;\n        int ans=0; \n        while(hi>=lo)\n        {\n            int mid=(lo+hi)/2;\n            if(mid*mid<=x)\n            {\n                ans=mid;\n                lo=mid+1;\n            }\n            else\n            {\n                hi=mid-1;\n            }\n        }\n        return ans;\n        \n    }\n}",
      "compare_result": "111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    },
    {
      "id": 196368282,
      "lang": "java",
      "time": "5\u00a0months, 1\u00a0week",
      "timestamp": 1545437419,
      "status_display": "Accepted",
      "runtime": "7 ms",
      "url": "/submissions/detail/196368282/",
      "is_pending": "Not Pending",
      "title": "The Maze III",
      "memory": "26 MB",
      "code": "class Solution {\n    public List<Pair> child_states(int[][] maze, Pair start, int[] hole)\n    {\n        List<Pair> children=new ArrayList<>();\n        int[][] moves=new int[][]{{0,-1},{0,1},{-1,0},{1,0}};\n        String[] directions= new String[]{\"l\",\"r\",\"u\",\"d\"};\n        int count=start.dist;\n        String dir=start.dir;\n        for(int i=0; i<moves.length; i++)\n        {\n            count=start.dist;\n            int[] move= moves[i];\n            String direction= directions[i];\n            int[] temp=new int[]{start.x,start.y};\n            while(temp[0]>=0 && temp[0]<maze.length && temp[1]>=0 && temp[1]<maze[0].length && maze[temp[0]][temp[1]]!=1 && !(temp[0]==hole[0] && temp[1]==hole[1]))\n            {\n                temp[0]+=move[0];\n                temp[1]+=move[1];\n                count++;\n            }\n            if(!(temp[0]==hole[0] && temp[1]==hole[1]))\n            {\n                temp[0]-=move[0];\n                temp[1]-=move[1];\n                count--;\n            }\n            //System.out.println(temp[0]+\" \"+ temp[1] + \" \" +start[0]+ \" \" + start[1]);\n            if(!(temp[0]==start.x && temp[1]==start.y))\n            {\n                //System.out.println(\"acme hre e\");\n                children.add(new Pair(temp[0],temp[1],count,dir+direction));\n            }\n        }\n        return children;\n        \n    }\n    /**\n    public boolean hasPath(int[][] maze , int[] start, int[] destination, boolean[][] visited)\n    {\n        if(start[0]<0 || start[0]>= maze.length || start[1]<0 || start[1]>=maze[0].length || visited[start[0]][start[1]])\n            return false;\n        else if(start[0]==destination[0] && start[1]==destination[1])\n            return true;\n        visited[start[0]][start[1]]=true;\n        for(Pair child : child_states(maze,start))\n        {\n            if(!visited[child.x][child.y])\n                if(hasPath(maze,new int[]{child.x,child.y},destination,visited))\n                    return true;\n        }\n        visited[start[0]][start[1]]=false;\n        return false;\n    }\n    */\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\n        if(maze==null || ball == null || hole == null)\n            return \"impossible\";\n        //System.out.println(child_states(maze,start));\n        boolean[][] visited = new boolean[maze.length][maze[0].length];\n        //return false;\n        //return hasPath(maze,start,destination,visited);\n        //ArrayDeque<Pair> queue=new ArrayDeque<>();\n        PriorityQueue<Pair> queue=new PriorityQueue<>();\n        queue.add(new Pair(ball[0],ball[1],0,\"\"));\n        int flag=-1;\n        String result=\"\";\n        while(!queue.isEmpty())\n        {\n            Pair current=queue.poll();\n            if(flag!=-1 && flag<current.dist)\n            {\n                //System.out.println(\"break \" + current.dir);\n                break;\n            }\n            //System.out.println(current);\n            if(current.x==hole[0] && current.y==hole[1])\n            {\n                //terminal state\n                if(flag==-1)\n                {\n                    //System.out.println(\"flag is set \"+current.dir);\n                    flag=current.dist;\n                    result=current.dir;\n                }\n                else\n                {\n                    //System.out.println(\"flag might be set again \"+current.dir);\n                    result=result.compareTo(current.dir)<0 ? result: current.dir;\n                }  \n            }\n            if(!visited[current.x][current.y])\n            {\n                visited[current.x][current.y]=true;\n                for(Pair child : child_states(maze,current,hole))\n                {\n                    //System.out.println(current + \" \" + child);\n                    if(!visited[child.x][child.y])\n                        queue.add(child);\n                }\n            }\n            //System.out.println(\" queue is \"+ queue);\n        }\n        if(flag==-1)\n            return \"impossible\";\n        else \n            return result;\n    }\n}\nclass Pair implements Comparable<Pair>\n{\n    int x,y,dist;\n    String dir;\n    public Pair(int x ,int y ,int dist, String dir)\n    {\n        this.x=x;\n        this.y=y;\n        this.dist=dist;\n        this.dir=dir;\n    }\n    public String toString()\n    {\n        return this.x+\" \"+ this.y+\" \"+ this.dist+ \" \"+ dir;\n    }\n    public int compareTo(Pair b)\n    {\n        if(Integer.compare(this.dist,b.dist)==0)\n        {\n            if(Integer.compare(this.x,b.x)==0)\n            {\n                if(Integer.compare(this.y,b.y)==0)\n                    return this.dir.compareTo(b.dir);\n                else\n                    return Integer.compare(this.y,b.y);\n            }\n            else\n                return Integer.compare(this.x,b.x);\n        \n        }\n        else \n            return Integer.compare(this.dist,b.dist);\n    }\n}",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 196368241,
      "lang": "java",
      "time": "5\u00a0months, 1\u00a0week",
      "timestamp": 1545437401,
      "status_display": "Accepted",
      "runtime": "34 ms",
      "url": "/submissions/detail/196368241/",
      "is_pending": "Not Pending",
      "title": "The Maze III",
      "memory": "24.5 MB",
      "code": "class Solution {\n    public List<Pair> child_states(int[][] maze, Pair start, int[] hole)\n    {\n        List<Pair> children=new ArrayList<>();\n        int[][] moves=new int[][]{{0,-1},{0,1},{-1,0},{1,0}};\n        String[] directions= new String[]{\"l\",\"r\",\"u\",\"d\"};\n        int count=start.dist;\n        String dir=start.dir;\n        for(int i=0; i<moves.length; i++)\n        {\n            count=start.dist;\n            int[] move= moves[i];\n            String direction= directions[i];\n            int[] temp=new int[]{start.x,start.y};\n            while(temp[0]>=0 && temp[0]<maze.length && temp[1]>=0 && temp[1]<maze[0].length && maze[temp[0]][temp[1]]!=1 && !(temp[0]==hole[0] && temp[1]==hole[1]))\n            {\n                temp[0]+=move[0];\n                temp[1]+=move[1];\n                count++;\n            }\n            if(!(temp[0]==hole[0] && temp[1]==hole[1]))\n            {\n                temp[0]-=move[0];\n                temp[1]-=move[1];\n                count--;\n            }\n            //System.out.println(temp[0]+\" \"+ temp[1] + \" \" +start[0]+ \" \" + start[1]);\n            if(!(temp[0]==start.x && temp[1]==start.y))\n            {\n                //System.out.println(\"acme hre e\");\n                children.add(new Pair(temp[0],temp[1],count,dir+direction));\n            }\n        }\n        return children;\n        \n    }\n    /**\n    public boolean hasPath(int[][] maze , int[] start, int[] destination, boolean[][] visited)\n    {\n        if(start[0]<0 || start[0]>= maze.length || start[1]<0 || start[1]>=maze[0].length || visited[start[0]][start[1]])\n            return false;\n        else if(start[0]==destination[0] && start[1]==destination[1])\n            return true;\n        visited[start[0]][start[1]]=true;\n        for(Pair child : child_states(maze,start))\n        {\n            if(!visited[child.x][child.y])\n                if(hasPath(maze,new int[]{child.x,child.y},destination,visited))\n                    return true;\n        }\n        visited[start[0]][start[1]]=false;\n        return false;\n    }\n    */\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\n        if(maze==null || ball == null || hole == null)\n            return \"impossible\";\n        //System.out.println(child_states(maze,start));\n        boolean[][] visited = new boolean[maze.length][maze[0].length];\n        //return false;\n        //return hasPath(maze,start,destination,visited);\n        //ArrayDeque<Pair> queue=new ArrayDeque<>();\n        PriorityQueue<Pair> queue=new PriorityQueue<>();\n        queue.add(new Pair(ball[0],ball[1],0,\"\"));\n        int flag=-1;\n        String result=\"\";\n        while(!queue.isEmpty())\n        {\n            Pair current=queue.poll();\n            if(flag!=-1 && flag<current.dist)\n            {\n                System.out.println(\"break \" + current.dir);\n                break;\n            }\n            //System.out.println(current);\n            if(current.x==hole[0] && current.y==hole[1])\n            {\n                //terminal state\n                if(flag==-1)\n                {\n                    System.out.println(\"flag is set \"+current.dir);\n                    flag=current.dist;\n                    result=current.dir;\n                }\n                else\n                {\n                    System.out.println(\"flag might be set again \"+current.dir);\n                    result=result.compareTo(current.dir)<0 ? result: current.dir;\n                }  \n            }\n            if(!visited[current.x][current.y])\n            {\n                visited[current.x][current.y]=true;\n                for(Pair child : child_states(maze,current,hole))\n                {\n                    //System.out.println(current + \" \" + child);\n                    if(!visited[child.x][child.y])\n                        queue.add(child);\n                }\n            }\n            System.out.println(\" queue is \"+ queue);\n        }\n        if(flag==-1)\n            return \"impossible\";\n        else \n            return result;\n    }\n}\nclass Pair implements Comparable<Pair>\n{\n    int x,y,dist;\n    String dir;\n    public Pair(int x ,int y ,int dist, String dir)\n    {\n        this.x=x;\n        this.y=y;\n        this.dist=dist;\n        this.dir=dir;\n    }\n    public String toString()\n    {\n        return this.x+\" \"+ this.y+\" \"+ this.dist+ \" \"+ dir;\n    }\n    public int compareTo(Pair b)\n    {\n        if(Integer.compare(this.dist,b.dist)==0)\n        {\n            if(Integer.compare(this.x,b.x)==0)\n            {\n                if(Integer.compare(this.y,b.y)==0)\n                    return this.dir.compareTo(b.dir);\n                else\n                    return Integer.compare(this.y,b.y);\n            }\n            else\n                return Integer.compare(this.x,b.x);\n        \n        }\n        else \n            return Integer.compare(this.dist,b.dist);\n    }\n}",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 196367646,
      "lang": "java",
      "time": "5\u00a0months, 1\u00a0week",
      "timestamp": 1545437103,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/196367646/",
      "is_pending": "Not Pending",
      "title": "The Maze III",
      "memory": "N/A",
      "code": "class Solution {\n    public List<Pair> child_states(int[][] maze, Pair start, int[] hole)\n    {\n        List<Pair> children=new ArrayList<>();\n        int[][] moves=new int[][]{{0,-1},{0,1},{-1,0},{1,0}};\n        String[] directions= new String[]{\"l\",\"r\",\"u\",\"d\"};\n        int count=start.dist;\n        String dir=start.dir;\n        for(int i=0; i<moves.length; i++)\n        {\n            count=start.dist;\n            int[] move= moves[i];\n            String direction= directions[i];\n            int[] temp=new int[]{start.x,start.y};\n            while(temp[0]>=0 && temp[0]<maze.length && temp[1]>=0 && temp[1]<maze[0].length && maze[temp[0]][temp[1]]!=1 && !(temp[0]==hole[0] && temp[1]==hole[1]))\n            {\n                temp[0]+=move[0];\n                temp[1]+=move[1];\n                count++;\n            }\n            if(!(temp[0]==hole[0] && temp[1]==hole[1]))\n            {\n                temp[0]-=move[0];\n                temp[1]-=move[1];\n                count--;\n            }\n            //System.out.println(temp[0]+\" \"+ temp[1] + \" \" +start[0]+ \" \" + start[1]);\n            if(!(temp[0]==start.x && temp[1]==start.y))\n            {\n                //System.out.println(\"acme hre e\");\n                children.add(new Pair(temp[0],temp[1],count,dir+direction));\n            }\n        }\n        return children;\n        \n    }\n    /**\n    public boolean hasPath(int[][] maze , int[] start, int[] destination, boolean[][] visited)\n    {\n        if(start[0]<0 || start[0]>= maze.length || start[1]<0 || start[1]>=maze[0].length || visited[start[0]][start[1]])\n            return false;\n        else if(start[0]==destination[0] && start[1]==destination[1])\n            return true;\n        visited[start[0]][start[1]]=true;\n        for(Pair child : child_states(maze,start))\n        {\n            if(!visited[child.x][child.y])\n                if(hasPath(maze,new int[]{child.x,child.y},destination,visited))\n                    return true;\n        }\n        visited[start[0]][start[1]]=false;\n        return false;\n    }\n    */\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\n        if(maze==null || ball == null || hole == null)\n            return \"impossible\";\n        //System.out.println(child_states(maze,start));\n        boolean[][] visited = new boolean[maze.length][maze[0].length];\n        //return false;\n        //return hasPath(maze,start,destination,visited);\n        //ArrayDeque<Pair> queue=new ArrayDeque<>();\n        PriorityQueue<Pair> queue=new PriorityQueue<>();\n        queue.add(new Pair(ball[0],ball[1],0,\"\"));\n        int flag=-1;\n        String result=\"\";\n        while(!queue.isEmpty())\n        {\n            Pair current=queue.poll();\n            if(flag!=-1 && flag<current.dist)\n            {\n                //System.out.println(\"break \" + current.dir);\n                break;\n            }\n            //System.out.println(current);\n            if(current.x==hole[0] && current.y==hole[1])\n            {\n                //terminal state\n                if(flag==-1)\n                {\n                    //System.out.println(\"flag is set \"+current.dir);\n                    flag=current.dist;\n                    result=current.dir;\n                }\n                else\n                {\n                    //System.out.println(\"flag might be set again \"+current.dir);\n                    result=result.compareTo(current.dir)<0 ? result: current.dir;\n                }  \n            }\n            if(!visited[current.x][current.y])\n            {\n                visited[current.x][current.y]=true;\n                for(Pair child : child_states(maze,current,hole))\n                {\n                    //System.out.println(current + \" \" + child);\n                    if(!visited[child.x][child.y])\n                        queue.add(child);\n                }\n            }\n            //System.out.println(\" queue is \"+ queue);\n        }\n        if(flag==-1)\n            return \"impossible\";\n        else \n            return result;\n    }\n}\nclass Pair implements Comparable<Pair>\n{\n    int x,y,dist;\n    String dir;\n    public Pair(int x ,int y ,int dist, String dir)\n    {\n        this.x=x;\n        this.y=y;\n        this.dist=dist;\n        this.dir=dir;\n    }\n    public String toString()\n    {\n        return this.x+\" \"+ this.y+\" \"+ this.dist+ \" \"+ dir;\n    }\n    public int compareTo(Pair b)\n    {\n        if(Integer.compare(this.dist,b.dist)==0)\n        {\n            if(Integer.compare(this.x,b.x)==0)\n            {\n                return Integer.compare(this.y,b.y);\n            }\n            else\n                return Integer.compare(this.x,b.x);\n        \n        }\n        else \n            return Integer.compare(this.dist,b.dist);\n    }\n}",
      "compare_result": "1111111111111111111111111111111111111111111111111110111111011111"
    }
  ],
  "has_next": true,
  "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22196367646%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222018-12-22T00%3A05%3A03.411507%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%221448507%22%7D%7D"
}