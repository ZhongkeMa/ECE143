{
  "submissions_dump": [
    {
      "id": 221272425,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554846729,
      "status_display": "Accepted",
      "runtime": "8 ms",
      "url": "/submissions/detail/221272425/",
      "is_pending": "Not Pending",
      "title": "Climbing Stairs",
      "memory": "8.4 MB",
      "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        if(n==1)\n            return 1;\n        \n        if(n==2)\n            return 2;\n        \n        vector<int> dp(n+1,0);\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 2;\n        \n        for(int i = 3; i<=n; i++)\n            dp[i] = dp[i-1] + dp[i-2];\n        \n        return dp[n];\n    }\n};",
      "compare_result": "111111111111111111111111111111111111111111111"
    },
    {
      "id": 221271532,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554846429,
      "status_display": "Accepted",
      "runtime": "16 ms",
      "url": "/submissions/detail/221271532/",
      "is_pending": "Not Pending",
      "title": "Valid Anagram",
      "memory": "9.5 MB",
      "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int len = s.size();\n        unordered_map<char,int> str1;\n        unordered_map<char,int> str2;\n        if(len!=t.size())\n            return false;\n        \n        for(int i = 0; i<len; i++){\n            str1[s[i]]++;\n            str2[t[i]]++;\n        }\n\n        if(str1==str2)\n            return true;\n        else\n            return false;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111"
    },
    {
      "id": 221271330,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554846368,
      "status_display": "Accepted",
      "runtime": "16 ms",
      "url": "/submissions/detail/221271330/",
      "is_pending": "Not Pending",
      "title": "Valid Anagram",
      "memory": "9.5 MB",
      "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int len = s.size();\n        int hashMap[26] = {0};\n        if(len!=t.size())\n            return false;\n        \n        for(int i = 0; i<len; i++){\n            hashMap[s[i]-'a']++;\n            hashMap[t[i]-'a']--;\n        }\n\n        for(int i = 0; i<26; i++){\n            if(hashMap[i])\n                return false;\n        }\n        return true;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111"
    },
    {
      "id": 221270605,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554846142,
      "status_display": "Accepted",
      "runtime": "16 ms",
      "url": "/submissions/detail/221270605/",
      "is_pending": "Not Pending",
      "title": "Valid Anagram",
      "memory": "9.5 MB",
      "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int len = s.size();\n        unordered_map<char,int> str1;\n        unordered_map<char,int> str2;\n        if(len!=t.size())\n            return false;\n        \n        for(int i = 0; i<len; i++){\n            str1[s[i]]++;\n            str2[t[i]]++;\n        }\n\n        if(str1==str2)\n            return true;\n        else\n            return false;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111"
    },
    {
      "id": 221269909,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554845904,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/221269909/",
      "is_pending": "Not Pending",
      "title": "Valid Anagram",
      "memory": "N/A",
      "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int len = s.size();\n        unordered_map<char,int> str;\n        if(len!=t.size())\n            return false;\n        \n        for(int i = 0; i<len; i++){\n            str[s[i]]++;\n            str[t[i]]--;\n            if(str[t[i]]==0)\n                str.erase(t[i]);\n        }\n\n        if(str.empty())\n            return true;\n        else\n            return false;\n    }\n};",
      "compare_result": "0111101111111101011111111100011101"
    },
    {
      "id": 221269601,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554845808,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/221269601/",
      "is_pending": "Not Pending",
      "title": "Valid Anagram",
      "memory": "N/A",
      "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int len = s.size();\n        unordered_map<char,int> str;\n        if(len!=t.size())\n            return false;\n        \n        for(int i = 0; i<len; i++){\n            str[s[i]]++;\n            str[t[i]]--;\n            if(str[t[i]]==0)\n                str.erase(t[i]);\n        }\n\n        if(str.empty())\n            return true;\n        else\n            return true;\n    }\n};",
      "compare_result": "1110111110000110100000000011100110"
    },
    {
      "id": 221268638,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554845491,
      "status_display": "Accepted",
      "runtime": "28 ms",
      "url": "/submissions/detail/221268638/",
      "is_pending": "Not Pending",
      "title": "Valid Anagram",
      "memory": "9.6 MB",
      "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int len = s.size();\n        if(len!=t.size())\n            return false;\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n\n        if(s.compare(t)!=0)\n            return false;\n        else\n            return true;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111"
    },
    {
      "id": 221268230,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554845339,
      "status_display": "Accepted",
      "runtime": "24 ms",
      "url": "/submissions/detail/221268230/",
      "is_pending": "Not Pending",
      "title": "Valid Anagram",
      "memory": "9.6 MB",
      "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        unordered_map<char,int> str;\n        \n        int len = s.size();\n        if(len!=t.size())\n            return false;\n        \n        for(int i = 0; i<len; i++){\n            str[s[i]]++;\n            str[t[i]]--;\n        }\n        \n        for(auto iter:str) {\n            if(iter.second!=0)\n                return false;\n        }\n        \n        return true;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111"
    },
    {
      "id": 221267894,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554845203,
      "status_display": "Accepted",
      "runtime": "16 ms",
      "url": "/submissions/detail/221267894/",
      "is_pending": "Not Pending",
      "title": "Valid Anagram",
      "memory": "9.5 MB",
      "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        unordered_map<char,int> str1;\n        unordered_map<char,int> str2;\n        \n        int len = s.size();\n        if(len!=t.size())\n            return false;\n        \n        for(int i = 0; i<len; i++){\n            str1[s[i]]++;\n            str2[t[i]]++;\n        }\n        \n        if(str1==str2)\n            return true;\n        else\n            return false;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111"
    },
    {
      "id": 221267867,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554845191,
      "status_display": "Compile Error",
      "runtime": "N/A",
      "url": "/submissions/detail/221267867/",
      "is_pending": "Not Pending",
      "title": "Valid Anagram",
      "memory": "N/A",
      "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        unordered_map<char,int> str1;\n        unordered_map<char,int> str2;\n        \n        int len = s.size();\n        if(len!=t.size())\n            return false;\n        \n        for(int i = 0; i<len; i++)\n            str1[s[i]]++;\n            str2[t[i]]++;\n        }\n        \n        if(str1==str2)\n            return true;\n        else\n            return false;\n    }\n};",
      "compare_result": null
    },
    {
      "id": 221267625,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554845105,
      "status_display": "Accepted",
      "runtime": "28 ms",
      "url": "/submissions/detail/221267625/",
      "is_pending": "Not Pending",
      "title": "Valid Anagram",
      "memory": "9.6 MB",
      "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        unordered_map<char,int> str1;\n        unordered_map<char,int> str2;\n        \n        if(s.size()!=t.size())\n            return false;\n        \n        string::iterator iter1 = s.begin();\n        string::iterator iter2 = t.begin();\n        \n        while(iter1!=s.end() && iter2!=t.end()){\n            str1[*iter1]++;\n            iter1++;\n            \n            str2[*iter2]++;\n            iter2++;\n        }\n        \n        if(str1==str2)\n            return true;\n        else\n            return false;\n    }\n};",
      "compare_result": "1111111111111111111111111111111111"
    },
    {
      "id": 220958576,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554740100,
      "status_display": "Accepted",
      "runtime": "336 ms",
      "url": "/submissions/detail/220958576/",
      "is_pending": "Not Pending",
      "title": "K Closest Points to Origin",
      "memory": "63.2 MB",
      "code": "#include <queue>\nclass Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\n        \n        if(K<=0 || points.empty())\n            return vector<vector<int>>();\n\n        priority_queue<pair<int,vector<int>>> kPoints;\n        int current_size = 0;\n        for(auto iter = points.begin(); iter!=points.end(); iter++){\n            int dist = computeDist(*iter);\n            //if(current_size<K) {\n                kPoints.push(make_pair(-dist, *iter));\n                current_size++;\n            /*}\n            else {\n                auto temp = kPoints.top();\n                cout<<\"Distance to push: \"<<dist<<\", existing max dist: \"\n                kPoints.pop();\n                kPoints.push(make_pair(-dist,*iter));\n            }*/\n        }\n        //cout<<\"Size: \"<<kPoints.size()<<\", current_size: \"<<current_size<<endl;\n        vector<vector<int>> result;\n        //priority_queue<pair<int,vector<int>>>::iterator iter;\n        int counter = K;\n        while(!kPoints.empty()&&counter>0){\n            pair<int,vector<int>> val = kPoints.top();\n            result.push_back(val.second);\n            kPoints.pop();\n            counter--;\n        }\n        \n        return result;\n    }\n    \nprivate:\n    int computeDist(vector<int> point){\n        return (point[0]*point[0]+point[1]*point[1]);\n    }\n};",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 220902032,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554715803,
      "status_display": "Accepted",
      "runtime": "116 ms",
      "url": "/submissions/detail/220902032/",
      "is_pending": "Not Pending",
      "title": "LRU Cache",
      "memory": "37.9 MB",
      "code": "class LRUCache {\npublic:\n    LRUCache(int capacity) {\n        cacheCapacity = capacity;\n        currentSize=0;\n    }\n\n    int get(int key) {\n        if(hashMap.find(key)==hashMap.end())\n            return -1;\n        else {\n            values.splice(values.begin(),values,hashMap[key]);\n            return hashMap[key]->second;\n        }\n    }\n\n    void put(int key, int value) {\n        if (cacheCapacity<=0) return;\n        if(hashMap.find(key)==hashMap.end()){\n            if(currentSize==cacheCapacity)\n            {\n                auto it=values.end();\n                --it;\n                hashMap.erase(it->first);           \n                values.pop_back();\n                currentSize--;\n            }\n            values.emplace_front(key,value);\n            hashMap.emplace(key,values.begin());\n            currentSize++;\n            }\n        else {\n            hashMap[key]->second=value;\n            values.splice(values.begin(),values,hashMap[key]);\n            }\n    }\n\nprivate:\n    unordered_map<int,list<pair<int,int>>::iterator> hashMap;\n    list<pair<int,int>> values;\n    int currentSize;\n    int cacheCapacity;\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */",
      "compare_result": "111111111111111111"
    },
    {
      "id": 220901402,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554715512,
      "status_display": "Accepted",
      "runtime": "140 ms",
      "url": "/submissions/detail/220901402/",
      "is_pending": "Not Pending",
      "title": "LRU Cache",
      "memory": "40.2 MB",
      "code": "class LRUCache {\npublic:\n    unordered_map<int, list<pair<int,int>>::iterator> cacheTable;\n    list<pair<int,int>> cacheVals;\n    int max_size;\n        \n    LRUCache(int capacity) {\n        max_size = capacity;\n    }\n    \n    int get(int key) {\n        /*cout<<\"To GET Key: \"<<key<<endl;\n        for(auto it = cacheTable.begin(); it!=cacheTable.end(); it++){\n            cout<<\"Traverse Key: \"<<it->first<<endl;\n        }*/\n        if(cacheTable.find(key)!=cacheTable.end()){\n            auto iter = cacheTable[key];\n            int result = iter->second;\n            cacheVals.push_front(make_pair(iter->first, iter->second));\n            cacheVals.erase(iter);\n            cacheTable[key] = cacheVals.begin();\n            //cout<<\"GOT Key: \"<<key<<\", Val:\"<<result<<endl;\n            return result;\n        }\n        else \n            return -1;\n    }\n\n    void put(int key, int value) {\n        //cout<<\"To PUT Key: \"<<key<<\", Val:\"<<value<<endl;\n        if(max_size<=0) return;\n\n        if(cacheTable.find(key)!=cacheTable.end()){\n            auto iter = cacheTable[key];\n            cacheVals.push_front(make_pair(iter->first, value));\n            cacheVals.erase(iter);\n            cacheTable[key] = cacheVals.begin();\n            //cout<<\"PUT updated element Key: \"<<cacheVals.begin()->first<<\", Value: \"<<cacheVals.begin()->second<<endl;\n        }\n        else {\n            if(cacheVals.size()<max_size){\n                cacheVals.push_front(make_pair(key,value));\n                cacheTable[key] = cacheVals.begin();\n                //cout<<\"PUT Key: \"<<cacheVals.begin()->first<<\", Value: \"<<cacheVals.begin()->second<<endl;\n            }\n            else {\n                auto toDel = --cacheVals.end();\n                //cout<<\"Deleting key: \"<<toDel->first<<endl;\n                auto it = cacheTable.find(toDel->first);\n                cacheTable.erase(it);\n                cacheVals.erase(toDel);\n                cacheVals.push_front(make_pair(key,value));\n                cacheTable[key] = cacheVals.begin();\n                //cout<<\"PUT new element Key: \"<<cacheVals.begin()->first<<\", Value: \"<<cacheVals.begin()->second<<endl;\n            }\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */",
      "compare_result": "111111111111111111"
    },
    {
      "id": 220892610,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554711659,
      "status_display": "Accepted",
      "runtime": "28 ms",
      "url": "/submissions/detail/220892610/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "11.4 MB",
      "code": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int rows = grid.size();\n        if(rows==0)\n            return 0;\n        int cols = grid[0].size();        \n        vector<vector<bool>> visited(rows,vector<bool>(cols,0));\n        int noOfIslands=0;\n\n        for(int i = 0; i<rows; i++) {\n            for(int j = 0; j<cols; j++) {\n                if(grid[i][j]=='1' && !visited[i][j]) {\n                    noOfIslands++;\n                    markNeighbors(grid,visited,i,j,rows,cols);\n                }\n            }\n        }\n        return noOfIslands;\n    }\n    \n    void markNeighbors(vector<vector<char>>& grid, vector<vector<bool>>&visited, int r, int c, int rows, int cols){\n        visited[r][c]=true;\n        if((r-1>=0) && (grid[r-1][c]=='1') && (!visited[r-1][c]))\n           markNeighbors(grid,visited,r-1,c,rows,cols);\n        if((c-1>=0) && (grid[r][c-1]=='1') && (!visited[r][c-1]))\n           markNeighbors(grid,visited,r,c-1,rows,cols);\n        if((r+1<rows) && (grid[r+1][c]=='1') && (!visited[r+1][c]))\n           markNeighbors(grid,visited,r+1,c,rows,cols);\n        if((c+1<cols) && (grid[r][c+1]=='1') && (!visited[r][c+1]))\n           markNeighbors(grid,visited,r,c+1,rows,cols);\n    }\n};",
      "compare_result": "11111111111111111111111111111111111111111111111"
    },
    {
      "id": 220892435,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554711584,
      "status_display": "Accepted",
      "runtime": "28 ms",
      "url": "/submissions/detail/220892435/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "11.3 MB",
      "code": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int row = grid.size();\n        if(row==0) return 0;\n        int col = grid[0].size();\n        vector<vector<bool>> visited(row, vector<bool>(col,false));\n        int islandCount=0;\n        for(auto i = 0; i<row; i++){\n            for(auto j = 0; j<col; j++){\n                if(grid[i][j]=='1' && !visited[i][j]){\n                    //visited[i][j] = true;\n                    islandCount++;\n                    markNeighbors(grid, visited, i, j, row, col);\n                }\n            }\n        }\n        return islandCount;\n    }\n\nprivate:\n    void markNeighbors(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int rows, int cols){\n        visited[i][j] = true;\n        if(i>0 && (grid[i-1][j] == '1') && !visited[i-1][j]) markNeighbors(grid, visited, i-1, j, rows, cols);\n        if(j>0 && (grid[i][j-1] == '1') && !visited[i][j-1]) markNeighbors(grid, visited, i, j-1, rows, cols);\n        if(i<rows-1 && (grid[i+1][j] == '1') && !visited[i+1][j]) markNeighbors(grid, visited, i+1, j, rows, cols);\n        if(j<cols-1 && (grid[i][j+1] == '1') && !visited[i][j+1]) markNeighbors(grid, visited, i, j+1, rows, cols);\n    }\n};",
      "compare_result": "11111111111111111111111111111111111111111111111"
    },
    {
      "id": 220892149,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554711474,
      "status_display": "Accepted",
      "runtime": "28 ms",
      "url": "/submissions/detail/220892149/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "11.4 MB",
      "code": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int row = grid.size();\n        if(row==0) return 0;\n        int col = grid[0].size();\n        vector<vector<bool>> visited(row, vector<bool>(col,false));\n        int islandCount=0;\n        for(auto i = 0; i<grid.size(); i++){\n            for(auto j = 0; j<grid[i].size(); j++){\n                if(grid[i][j]=='1' && !visited[i][j]){\n                    //visited[i][j] = true;\n                    islandCount++;\n                    markNeighbors(grid, visited, i, j);\n                }\n            }\n        }\n        return islandCount;\n    }\n\nprivate:\n    void markNeighbors(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j){\n        visited[i][j] = true;\n        int row = grid.size();\n        if(i>0 && (grid[i-1][j] == '1') && !visited[i-1][j]) markNeighbors(grid, visited, i-1, j);\n        if(j>0 && (grid[i][j-1] == '1') && !visited[i][j-1]) markNeighbors(grid, visited, i, j-1);\n        if(i<grid.size()-1 && (grid[i+1][j] == '1') && !visited[i+1][j]) markNeighbors(grid, visited, i+1, j);\n        if(j<grid[i].size()-1 && (grid[i][j+1] == '1') && !visited[i][j+1]) markNeighbors(grid, visited, i, j+1);\n    }\n};",
      "compare_result": "11111111111111111111111111111111111111111111111"
    },
    {
      "id": 220891760,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554711312,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/220891760/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "N/A",
      "code": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid.size(),false));\n        int islandCount=0;\n        for(auto i = 0; i<grid.size(); i++){\n            for(auto j = 0; j<grid[i].size(); j++){\n                if(grid[i][j]=='1' && !visited[i][j]){\n                    //visited[i][j] = true;\n                    islandCount++;\n                    markNeighbors(grid, visited, i, j);\n                }\n            }\n        }\n        return islandCount;\n    }\n\nprivate:\n    void markNeighbors(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j){\n        visited[i][j] = true;\n        if(i>0 && (grid[i-1][j] == '1') && !visited[i-1][j]) markNeighbors(grid, visited, i-1, j);\n        if(j>0 && (grid[i][j-1] == '1') && !visited[i][j-1]) markNeighbors(grid, visited, i, j-1);\n        if(i<grid.size()-1 && (grid[i+1][j] == '1') && !visited[i+1][j]) markNeighbors(grid, visited, i+1, j);\n        if(j<grid[i].size()-1 && (grid[i][j+1] == '1') && !visited[i][j+1]) markNeighbors(grid, visited, i, j+1);\n    }\n};",
      "compare_result": "11111111101011111111111111111100000000000000000"
    },
    {
      "id": 220891033,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554711008,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/220891033/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "N/A",
      "code": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid.size(),false));\n        int islandCount=0;\n        for(auto i = 0; i<grid.size(); i++){\n            for(auto j = 0; j<grid[i].size(); j++){\n                if(grid[i][j]=='1' && ~visited[i][j]){\n                    //visited[i][j] = true;\n                    islandCount++;\n                    markNeighbors(grid, visited, i, j);\n                }\n            }\n        }\n        return islandCount;\n    }\n\nprivate:\n    void markNeighbors(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j){\n        visited[i][j] = true;\n        if(i>0 && (grid[i-1][j] == '1') && ~visited[i-1][j]) markNeighbors(grid, visited, i-1, j);\n        if(i>0 && (grid[i-1][j] == '1') && ~visited[i-1][j]) markNeighbors(grid, visited, i-1, j);\n        if(i>0 && (grid[i-1][j] == '1') && ~visited[i-1][j]) markNeighbors(grid, visited, i-1, j);\n    }\n};",
      "compare_result": "00111100101011110000100010100000000000000000000"
    },
    {
      "id": 220889495,
      "lang": "cpp",
      "time": "1\u00a0month, 2\u00a0weeks",
      "timestamp": 1554710400,
      "status_display": "Accepted",
      "runtime": "312 ms",
      "url": "/submissions/detail/220889495/",
      "is_pending": "Not Pending",
      "title": "K Closest Points to Origin",
      "memory": "61 MB",
      "code": "#include <map>\n\nclass Solution {\n    \nprivate:\n    double computeDistance(vector<int>point){\n        double distance = point[0]*point[0]+point[1]*point[1];\n        return distance;\n    }\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\n        if(K<=0 || points.empty())\n            return vector<vector<int>>();\n\n        int counter = 0; int excess = 0;\n        multimap<double,vector<vector<int>>::iterator> sortedDist;\n        //multimap<double,vector<vector<int>>::iterator>::iterator maxTracker;\n        auto maxTracker = sortedDist.rbegin();\n        for(auto iter = points.begin(); iter!=points.end(); iter++){\n            vector<int> current_point = *iter;\n            double dist = computeDistance(current_point);\n            if(counter<K){\n                sortedDist.insert(make_pair(dist,iter));\n                maxTracker = sortedDist.rbegin();\n                counter++;\n            }\n            else {\n                if(dist<maxTracker->first){\n                    sortedDist.insert(make_pair(dist,iter));\n                    maxTracker--;\n                }\n            }          \n        }\n        //cout<<sortedDist.size()<<\" is the size of the multimap\\n\";\n        int count = 0;\n        vector<vector<int>> result;\n        for(auto iter = sortedDist.begin(); iter!=sortedDist.end() && count<K; iter++) {\n            vector<int> cur_point = *(iter->second);\n            result.push_back(cur_point);\n            count++;\n        }\n        return result;\n    }\n};",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    }
  ],
  "has_next": true,
  "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22220889495%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222019-04-08T08%3A00%3A00.480302%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%22889093%22%7D%7D"
}