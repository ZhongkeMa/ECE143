{
  "submissions_dump": [
    {
      "id": 217009684,
      "lang": "python",
      "time": "2\u00a0months",
      "timestamp": 1553365199,
      "status_display": "Accepted",
      "runtime": "600 ms",
      "url": "/submissions/detail/217009684/",
      "is_pending": "Not Pending",
      "title": "Arithmetic Slices II - Subsequence",
      "memory": "59 MB",
      "code": "from collections import defaultdict\nclass Solution(object):\n    def numberOfArithmeticSlices(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        total = 0\n        dp = [defaultdict(int) for item in A]\n        for i in xrange(len(A)):\n            for j in xrange(i):\n                dp[i][A[i] - A[j]] += 1\n                if A[i]-A[j] in dp[j]:\n                    dp[i][A[i] - A[j]] += dp[j][A[i]-A[j]]\n                    total += dp[j][A[i]-A[j]]\n        return total\n                    \n                    \n        \n                    \n        \n        \n        \n                    \n                \n        \n        ",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 217005857,
      "lang": "python",
      "time": "2\u00a0months",
      "timestamp": 1553363952,
      "status_display": "Accepted",
      "runtime": "36 ms",
      "url": "/submissions/detail/217005857/",
      "is_pending": "Not Pending",
      "title": "Arithmetic Slices",
      "memory": "12 MB",
      "code": "class Solution(object):\n    def numberOfArithmeticSlices(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A)<3:\n            return 0\n        \n        dc=0\n        d=None\n        count=0\n        prev=A[0]\n        for number in A[1:]:\n            currdiff=number-prev\n            if currdiff==d:\n                dc+=1\n            else:\n                d=currdiff\n                dc=1\n            prev=number\n                \n            if dc>=2:\n                count+=dc-2+1\n                \n        return count\n            \n        ",
      "compare_result": "111111111111111"
    },
    {
      "id": 216891725,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553312170,
      "status_display": "Accepted",
      "runtime": "88 ms",
      "url": "/submissions/detail/216891725/",
      "is_pending": "Not Pending",
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "memory": "20.1 MB",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        while root:\n            if max(p.val, q.val) < root.val:\n                root = root.left\n            elif min(p.val, q.val) > root.val:\n                root = root.right\n            else:\n                return root\n        return None\n        ",
      "compare_result": "111111111111111111111111111"
    },
    {
      "id": 216891694,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553312158,
      "status_display": "Compile Error",
      "runtime": "N/A",
      "url": "/submissions/detail/216891694/",
      "is_pending": "Not Pending",
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "memory": "N/A",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        while root:\n        if max(p.val, q.val) < root.val:\n            root = root.left\n        elif min(p.val, q.val) > root.val:\n            root = root.right\n        else:\n            return root\n        return None\n        ",
      "compare_result": null
    },
    {
      "id": 216888338,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553311005,
      "status_display": "Accepted",
      "runtime": "264 ms",
      "url": "/submissions/detail/216888338/",
      "is_pending": "Not Pending",
      "title": "Maximum Binary Tree",
      "memory": "12.5 MB",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def constructMaximumBinaryTree(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not nums:\n            return None\n        root, maxi = TreeNode(max(nums)), nums.index(max(nums))\n        root.left = self.constructMaximumBinaryTree(nums[:maxi])\n        root.right = self.constructMaximumBinaryTree(nums[maxi + 1:])\n        return root",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 216887405,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553310678,
      "status_display": "Accepted",
      "runtime": "112 ms",
      "url": "/submissions/detail/216887405/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "24.2 MB",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.max=-(2**32-1)\n        self.helper(root)\n        return self.max\n        \n        \n    def helper(self,node):\n        if not node:\n            return 0\n        \n        l=self.helper(node.left)\n        r=self.helper(node.right)\n        \n        self.max=max(self.max,max(0,l)+max(0,r)+node.val)\n        \n        return max(0,node.val+max(0,l,r))\n        \n        \n        ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 216883101,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553309188,
      "status_display": "Accepted",
      "runtime": "24 ms",
      "url": "/submissions/detail/216883101/",
      "is_pending": "Not Pending",
      "title": "Symmetric Tree",
      "memory": "12 MB",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        stack = [(root.left, root.right)]\n        while stack:\n            left, right = stack.pop()\n            if left is None and right is None:\n                continue\n            if left is None or right is None:\n                return False\n            if left.val == right.val:\n                stack.append((left.left, right.right))\n                stack.append((left.right, right.left))\n            else:\n                return False\n        return True",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 216858180,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553299082,
      "status_display": "Accepted",
      "runtime": "20 ms",
      "url": "/submissions/detail/216858180/",
      "is_pending": "Not Pending",
      "title": "Unique Binary Search Trees",
      "memory": "12 MB",
      "code": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n==0:\n            return 0\n        elif n==1:\n            return 1\n        elif n==2:\n            return 2\n        \n        dp=[0]*(n+1)\n        \n        dp[0]=1\n        dp[1]=1\n        dp[2]=2\n        \n        for i in range(3,n+1):\n            for j in range(1,i+1):\n                dp[i]+=dp[j-1]*dp[i-j]\n                \n        return dp[-1]\n        ",
      "compare_result": "1111111111111111111"
    },
    {
      "id": 216858077,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553299042,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/216858077/",
      "is_pending": "Not Pending",
      "title": "Unique Binary Search Trees",
      "memory": "N/A",
      "code": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp=[0]*(n+1)\n        \n        dp[0]=1\n        dp[1]=1\n        dp[2]=2\n        \n        for i in range(3,n+1):\n            for j in range(1,i+1):\n                dp[i]+=dp[j-1]*dp[i-j]\n                \n        return dp[-1]\n        ",
      "compare_result": "1000000000000000000"
    },
    {
      "id": 216852801,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553296872,
      "status_display": "Accepted",
      "runtime": "112 ms",
      "url": "/submissions/detail/216852801/",
      "is_pending": "Not Pending",
      "title": "Insert into a Binary Search Tree",
      "memory": "16 MB",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def insertIntoBST(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        stack=[]\n        node=root\n        found=False\n        while stack or node:\n            while node:\n                stack.append(node)\n                node=node.left\n            node=stack.pop()\n            if node.val>val:\n                found=True\n                break\n            node=node.right\n            \n        if found:\n            if node.left:\n                node=node.left\n                while node.right:\n                    node=node.right\n                node.right=TreeNode(val)\n            else:\n                node.left=TreeNode(val)\n        else:\n            node=root\n            while node.right:\n                node=node.right\n            node.right=TreeNode(val)\n        \n        return root\n        ",
      "compare_result": "1111111111111111111111111111111111"
    },
    {
      "id": 216852565,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553296758,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/216852565/",
      "is_pending": "Not Pending",
      "title": "Insert into a Binary Search Tree",
      "memory": "N/A",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def insertIntoBST(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        stack=[]\n        node=root\n        found=False\n        while stack or node:\n            while node:\n                stack.append(node)\n                node=node.left\n            node=stack.pop()\n            if node.val>val:\n                found=True\n                break\n            node=node.right\n            \n        if found:\n            if node.left:\n                node=node.left\n                while node.right:\n                    node=node.right\n                node.right=TreeNode(val)\n            else:\n                node.left=TreeNode(val)\n        else:\n            node.right=TreeNode(val)\n        \n        return root\n        ",
      "compare_result": "1111000000000000000000000000000000"
    },
    {
      "id": 216852109,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553296564,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/216852109/",
      "is_pending": "Not Pending",
      "title": "Insert into a Binary Search Tree",
      "memory": "N/A",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def insertIntoBST(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        stack=[]\n        node=root\n        while stack or node:\n            while node:\n                stack.append(node)\n                node=node.left\n            node=stack.pop()\n            if node.val>val:\n                break\n            node=node.right\n        \n        if node.left:\n            node=node.left\n            while node.right:\n                node=node.right\n\n            node.right=TreeNode(val)\n        else:\n            node.left=TreeNode(val)\n        \n        return root\n        ",
      "compare_result": "1111000000000000000000000000000000"
    },
    {
      "id": 216851200,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553296176,
      "status_display": "Accepted",
      "runtime": "128 ms",
      "url": "/submissions/detail/216851200/",
      "is_pending": "Not Pending",
      "title": "Insert into a Binary Search Tree",
      "memory": "16.1 MB",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def insertIntoBST(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return TreeNode(val)\n        \n        return self.helper(root,val,None)\n            \n        \n        \n    def helper(self,root,val,parent):\n        if not root:\n            if parent.val>val:\n                parent.left=TreeNode(val)\n            else:\n                parent.right=TreeNode(val)\n        else:\n            if val<root.val:\n                self.helper(root.left, val,root)\n            else:\n                self.helper(root.right, val,root)\n            \n        return root\n            \n            \n        ",
      "compare_result": "1111111111111111111111111111111111"
    },
    {
      "id": 216846995,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553294420,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/216846995/",
      "is_pending": "Not Pending",
      "title": "Verify Preorder Sequence in Binary Search Tree",
      "memory": "N/A",
      "code": "class Solution(object):\n    def verifyPreorder(self, preorder):\n        \"\"\"\n        :type preorder: List[int]\n        :rtype: bool\n        \"\"\"\n        self.preorder=preorder\n        maxim=2**32\n        minim=-2**32-1\n        return self.helper(0,len(self.preorder),minim,maxim)\n        \n        \n    def helper(self,i,l,minim,maxim):\n        if i==l:\n            return True\n        \n        ix=i\n        while ix<l:\n            if self.preorder[ix]<minim:\n                ix+=1\n            else:\n                break\n                \n        while ix<l:\n            if self.preorder[i]<maxim and self.preorder[i]>minim:\n                ix+=1\n            else:\n                return False\n            \n        return self.helper(i,ix,minim,min(maxim,self.preorder[i])) and self.helper(ix,l,minim,min(maxim,self.preorder[i]))\n        \n        ",
      "compare_result": "101000000100100010000111101011100010011011001001001001001001001"
    },
    {
      "id": 216844667,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553293495,
      "status_display": "Accepted",
      "runtime": "20 ms",
      "url": "/submissions/detail/216844667/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Preorder Traversal",
      "memory": "12 MB",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        stack=[]\n        node=root\n        result=[]\n        \n        while stack or node:\n            while node:\n                stack.append(node)\n                result.append(node.val)\n                node=node.left\n                \n            node=stack.pop()\n            node=node.right\n            \n        return result\n                ",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 216841207,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553292076,
      "status_display": "Accepted",
      "runtime": "40 ms",
      "url": "/submissions/detail/216841207/",
      "is_pending": "Not Pending",
      "title": "Diameter of Binary Tree",
      "memory": "14.8 MB",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.diameter=0\n        self.helper(root)\n        return self.diameter\n        \n        \n    def helper(self,node):\n        if not node:\n            return 0\n        \n        left=self.helper(node.left)\n        right=self.helper(node.right)\n        \n        self.diameter = max(self.diameter,left+right)\n        return max(left,right)+1\n        \n        ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 216840083,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553291633,
      "status_display": "Accepted",
      "runtime": "24 ms",
      "url": "/submissions/detail/216840083/",
      "is_pending": "Not Pending",
      "title": "Smallest Subtree with all the Deepest Nodes",
      "memory": "12.1 MB",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def subtreeWithAllDeepest(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        def deep(root,level):\n            if not root: return level, None\n            l, r = deep(root.left,level+1), deep(root.right,level+1)\n            \n            if l[0] > r[0]: return l[0], l[1]\n            elif l[0] < r[0]: return r[0], r[1]\n            else: return l[0], root\n        return deep(root,1)[1]\n        ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111"
    },
    {
      "id": 216838552,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553290978,
      "status_display": "Accepted",
      "runtime": "68 ms",
      "url": "/submissions/detail/216838552/",
      "is_pending": "Not Pending",
      "title": "Inorder Successor in BST",
      "memory": "20.2 MB",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def inorderSuccessor(self, root, p):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        node=root\n        successor=None\n        \n        while node:\n            if node.val==p.val:\n                break\n            else:\n                if node.val<p.val:\n                    node=node.right\n                else:\n                    successor,node=node,node.left\n                 \n        \n        if node.right:\n            successor=node.right\n            while successor.left:\n                successor=successor.left\n                \n        return successor if successor and successor.val>p.val else None\n            \n                    ",
      "compare_result": "111111111111111111111111"
    },
    {
      "id": 216838491,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553290954,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/216838491/",
      "is_pending": "Not Pending",
      "title": "Inorder Successor in BST",
      "memory": "N/A",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def inorderSuccessor(self, root, p):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        node=root\n        successor=None\n        \n        while node:\n            if node.val==p.val:\n                break\n            else:\n                if node.val<p.val:\n                    node=node.right\n                else:\n                    successor,node=node,node.left\n                 \n        \n        if node.right:\n            successor=node.right\n            while successor.left:\n                successor=successor.left\n        print(successor.val)        \n        return successor if successor and successor.val>p.val else None\n            \n                    ",
      "compare_result": "100000000000000000000000"
    },
    {
      "id": 216827641,
      "lang": "python",
      "time": "2\u00a0months, 1\u00a0week",
      "timestamp": 1553286811,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/216827641/",
      "is_pending": "Not Pending",
      "title": "Inorder Successor in BST",
      "memory": "N/A",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def inorderSuccessor(self, root, p):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        node=root\n        successor=None\n        \n        while node:\n            if node.val==p.val:\n                break\n            else:\n                if node.val<p.val:\n                    successor,node=node,node.right\n                else:\n                    successor,node=node,node.left\n                 \n        \n        if node.right:\n            successor=node.right\n            while successor.left:\n                successor=successor.left\n                \n        return successor if successor and successor.val>p.val else None\n            \n                    ",
      "compare_result": "111111111111101110101111"
    }
  ],
  "has_next": true,
  "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22216827641%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222019-03-22T20%3A33%3A31.095873%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%221546199%22%7D%7D"
}